From 3098b3ef905ba4005831886222a64671bd25cc2d Mon Sep 17 00:00:00 2001
From: Tennyson McCalla <tennyson.mccalla@gmail.com>
Date: Mon, 10 Feb 2025 18:39:23 -0600
Subject: [PATCH 3/3] feat: Major UI and architecture enhancements

---
 .gitignore                                    | 116 +++---
 Package.swift                                 |  29 +-
 README.md                                     |  64 ++++
 ReelAI/Models/Video.swift                     |  72 ++--
 ReelAI/Network/NetworkErrorHandler.swift      | 112 ++++++
 ReelAI/Network/NetworkMonitor.swift           | 170 +++++++++
 ReelAI/NetworkMonitor.swift                   |  49 ---
 ReelAI/Protocols/VideoUploadProtocols.swift   | 128 +++++++
 ReelAI/ReelAIApp.swift                        |   9 +-
 ReelAI/Services/AuthService.swift             |   5 +
 ReelAI/Services/DatabaseManager.swift         |   1 +
 ReelAI/Services/FirebaseDatabaseManager.swift | 178 +++++----
 ReelAI/Services/FirebaseStorageManager.swift  | 185 ++++++++-
 ReelAI/Services/StorageManager.swift          |   1 +
 ReelAI/VideoCache/VideoCacheManager.swift     | 228 ++++++++---
 ReelAI/VideoPicker.swift                      | 134 ++++---
 ReelAI/ViewModels/EditProfileViewModel.swift  |  74 +++-
 ReelAI/ViewModels/Feed/FeedPaginator.swift    | 198 ++++++----
 .../ViewModels/Feed/VideoFeedViewModel.swift  | 227 ++++++-----
 ReelAI/ViewModels/ProfileViewModel.swift      | 354 ++++++------------
 ReelAI/ViewModels/Upload/UploadManager.swift  |  49 +++
 ReelAI/ViewModels/Upload/VideoProcessor.swift |   1 +
 .../Upload/VideoUploadViewModel.swift         | 283 +++++++-------
 .../ViewModels/VideoManagementViewModel.swift |   8 +-
 ReelAI/Views/EditProfileView.swift            |  70 +++-
 ReelAI/Views/Feed/VideoFeedView.swift         | 247 +++---------
 ReelAI/Views/Player/PlayerViewModel.swift     | 100 ++++-
 ReelAI/Views/Player/VideoPlayerView.swift     | 183 +++++----
 ReelAI/Views/ProfileView.swift                | 256 ++++++++-----
 ReelAI/Views/Upload/VideoUploadView.swift     | 176 +++++----
 .../VideoManagement/VideoManagementView.swift |   7 +-
 31 files changed, 2290 insertions(+), 1424 deletions(-)
 create mode 100644 README.md
 create mode 100644 ReelAI/Network/NetworkErrorHandler.swift
 create mode 100644 ReelAI/Network/NetworkMonitor.swift
 delete mode 100644 ReelAI/NetworkMonitor.swift
 create mode 100644 ReelAI/Protocols/VideoUploadProtocols.swift

diff --git a/.gitignore b/.gitignore
index 263114d..f7f6e86 100644
--- a/.gitignore
+++ b/.gitignore
@@ -29,9 +29,44 @@ yarn-error.log*
 *.swo
 
 # Xcode
+#
+# gitignore contributors: remember to update Global/Xcode.gitignore, Objective-C.gitignore & Swift.gitignore
+
+## User settings
 xcuserdata/
-*.xcscmblueprint
-*.xccheckout
+
+## Obj-C/Swift specific
+*.hmap
+
+## App packaging
+*.ipa
+*.dSYM.zip
+*.dSYM
+
+## Playgrounds
+timeline.xctimeline
+playground.xcworkspace
+
+# Swift Package Manager
+#
+# Add this line if you want to avoid checking in source code from Swift Package Manager dependencies.
+.build/
+Packages/
+Package.resolved
+*.xcodeproj
+.swiftpm
+
+# Firebase
+GoogleService-Info.plist
+firebase-debug.log
+.firebase/
+
+# macOS
+.DS_Store
+.AppleDouble
+.LSOverride
+
+# Xcode
 DerivedData/
 *.moved-aside
 *.pbxuser
@@ -42,71 +77,36 @@ DerivedData/
 !default.mode2v3
 *.perspectivev3
 !default.perspectivev3
-*.hmap
-*.ipa
-*.dSYM.zip
-*.dSYM
-
-# CocoaPods
-Pods/
-*.xcworkspace
-!default.xcworkspace
-
-# Carthage
-Carthage/Build/
+*.xccheckout
+*.xcscmblueprint
+*.xcuserstate
 
-# Swift Package Manager
-.build/
-.swiftpm/
+# IDE
+.idea/
+*.swp
+*.swo
 
-# fastlane
+# Fastlane
 fastlane/report.xml
 fastlane/Preview.html
 fastlane/screenshots/**/*.png
 fastlane/test_output
 
-# Firebase
-GoogleService-Info.plist
-**/GoogleService-Info.plist
-
-# Environment files & Keys
-*.env
-*.env.*
-.env.local
-.env.development
-.env.test
-.env.production
-*.pem
-*.key
-*.keystore
-*.p12
-*.cer
-*.mobileprovision
-
-# Secrets
-**/secrets.*
-**/Secrets.*
-**/Keys.*
-**/keys.*
-**/Private.*
-**/private.*
-*Configuration.plist
-*Credentials.plist
-
-# OS generated files
-.DS_Store
-.DS_Store?
-._*
-.Spotlight-V100
-.Trashes
-ehthumbs.db
-Thumbs.db
+# Code Coverage
+*.coverage
+*.coveragexml
 
 # Other
-*.xcarchive
-*.xcuserstate
-timeline.xctimeline
-playground.xcworkspace
+*.log
+.env
+
+# CocoaPods
+Pods/
+*.xcworkspace
+!default.xcworkspace
+
+# Carthage
+Carthage/Build/
 
 # Planning documentation
 docs/
diff --git a/Package.swift b/Package.swift
index 0ed1159..7e322f7 100644
--- a/Package.swift
+++ b/Package.swift
@@ -3,9 +3,19 @@ import PackageDescription
 
 let package = Package(
     name: "ReelAI",
-    platforms: [.iOS(.v16)],
+    platforms: [
+        .iOS(.v17)
+    ],
+    products: [
+        .library(
+            name: "ReelAI",
+            targets: ["ReelAI"]),
+    ],
     dependencies: [
-        .package(url: "https://github.com/firebase/firebase-ios-sdk.git", from: "10.19.0")
+        .package(
+            url: "https://github.com/firebase/firebase-ios-sdk.git",
+            exact: "11.8.1"
+        ),
     ],
     targets: [
         .target(
@@ -13,8 +23,17 @@ let package = Package(
             dependencies: [
                 .product(name: "FirebaseAuth", package: "firebase-ios-sdk"),
                 .product(name: "FirebaseStorage", package: "firebase-ios-sdk"),
-                .product(name: "FirebaseDatabase", package: "firebase-ios-sdk")
-            ]
-        )
+                .product(name: "FirebaseDatabase", package: "firebase-ios-sdk"),
+                .product(name: "FirebaseFirestore", package: "firebase-ios-sdk"),
+                .product(name: "FirebaseCore", package: "firebase-ios-sdk"),
+                .product(name: "FirebaseSharedSwift", package: "firebase-ios-sdk"),
+            ],
+            path: "ReelAI"
+        ),
+        .testTarget(
+            name: "ReelAITests",
+            dependencies: ["ReelAI"],
+            path: "ReelAITests"
+        ),
     ]
 )
diff --git a/README.md b/README.md
new file mode 100644
index 0000000..ab84dcd
--- /dev/null
+++ b/README.md
@@ -0,0 +1,64 @@
+# ReelAI
+
+A modern iOS application for video sharing and management, built with SwiftUI and Firebase.
+
+## Features
+
+- Video upload and management
+- Real-time video feed
+- User profiles
+- Social interactions
+- Privacy controls
+- Efficient video processing and caching
+
+## Requirements
+
+- iOS 17.0+
+- Xcode 15.0+
+- Swift 5.9+
+
+## Installation
+
+1. Clone the repository
+```bash
+git clone https://github.com/yourusername/ReelAI.git
+cd ReelAI
+```
+
+2. Install dependencies using Swift Package Manager
+```bash
+xcodebuild -resolvePackageDependencies
+```
+
+3. Create a Firebase project and download the `GoogleService-Info.plist`
+4. Add the `GoogleService-Info.plist` to your Xcode project
+5. Build and run the project
+
+## Architecture
+
+- SwiftUI for the UI layer
+- MVVM architecture
+- Actor-based concurrency for thread safety
+- Firebase for backend services
+  - Realtime Database
+  - Storage
+  - Authentication
+  - Firestore
+
+## Dependencies
+
+- Firebase iOS SDK 11.8.1
+  - FirebaseAuth
+  - FirebaseStorage
+  - FirebaseDatabase
+  - FirebaseFirestore
+  - FirebaseCore
+  - FirebaseSharedSwift
+
+## License
+
+[Your chosen license]
+
+## Contact
+
+[Your contact information]
diff --git a/ReelAI/Models/Video.swift b/ReelAI/Models/Video.swift
index 67b6673..3a07034 100644
--- a/ReelAI/Models/Video.swift
+++ b/ReelAI/Models/Video.swift
@@ -6,7 +6,7 @@ struct Video: Identifiable, Codable, Hashable {
     let userId: String?
     let videoURL: URL
     let thumbnailURL: URL?
-    let createdAt: Date  // This is what we're using for timestamp
+    let createdAt: Date
     var caption: String
     var likes: Int
     var comments: Int
@@ -33,7 +33,7 @@ struct Video: Identifiable, Codable, Hashable {
         case userId
         case videoURL
         case thumbnailURL
-        case createdAt = "timestamp"  // Map createdAt to timestamp in Firebase
+        case createdAt = "timestamp"
         case caption
         case likes
         case comments
@@ -42,50 +42,50 @@ struct Video: Identifiable, Codable, Hashable {
         case lastEditedAt
     }
 
-    // Custom encoding to handle Date conversion for Firebase
-    func encode(to encoder: Encoder) throws {
-        var container = encoder.container(keyedBy: CodingKeys.self)
-        try container.encode(id, forKey: .id)
-        try container.encode(userId, forKey: .userId)
-        try container.encode(videoURL.absoluteString, forKey: .videoURL)
-        try container.encode(thumbnailURL?.absoluteString, forKey: .thumbnailURL)
-        // Convert Date to milliseconds timestamp for Firebase
-        try container.encode(Int(createdAt.timeIntervalSince1970 * 1000), forKey: .createdAt)
-        try container.encode(caption, forKey: .caption)
-        try container.encode(likes, forKey: .likes)
-        try container.encode(comments, forKey: .comments)
-        try container.encode(isDeleted, forKey: .isDeleted)
-        try container.encode(privacyLevel, forKey: .privacyLevel)
-        try container.encode(lastEditedAt?.timeIntervalSince1970, forKey: .lastEditedAt)
-    }
-
-    // Custom decoding to handle Firebase timestamp
     init(from decoder: Decoder) throws {
         let container = try decoder.container(keyedBy: CodingKeys.self)
+        
         id = try container.decode(String.self, forKey: .id)
-        userId = try container.decode(String?.self, forKey: .userId)
+        userId = try container.decodeIfPresent(String.self, forKey: .userId)
+        
+        // Handle video URL
         let videoURLString = try container.decode(String.self, forKey: .videoURL)
         guard let videoURL = URL(string: videoURLString) else {
-            throw DecodingError.dataCorruptedError(forKey: .videoURL, in: container, debugDescription: "Invalid URL string")
+            throw DecodingError.dataCorruptedError(forKey: .videoURL,
+                  in: container,
+                  debugDescription: "Invalid URL string: \(videoURLString)")
         }
         self.videoURL = videoURL
-
+        
+        // Handle optional thumbnail URL
         if let thumbnailURLString = try container.decodeIfPresent(String.self, forKey: .thumbnailURL) {
-            thumbnailURL = URL(string: thumbnailURLString)
+            self.thumbnailURL = URL(string: thumbnailURLString)
         } else {
-            thumbnailURL = nil
+            self.thumbnailURL = nil
         }
+        
+        createdAt = try container.decode(Date.self, forKey: .createdAt)
+        caption = try container.decodeIfPresent(String.self, forKey: .caption) ?? ""
+        likes = try container.decodeIfPresent(Int.self, forKey: .likes) ?? 0
+        comments = try container.decodeIfPresent(Int.self, forKey: .comments) ?? 0
+        isDeleted = try container.decodeIfPresent(Bool.self, forKey: .isDeleted) ?? false
+        privacyLevel = try container.decodeIfPresent(PrivacyLevel.self, forKey: .privacyLevel) ?? .public
+        lastEditedAt = try container.decodeIfPresent(Date.self, forKey: .lastEditedAt)
+    }
 
-        // Handle timestamp from Firebase (milliseconds)
-        let timestamp = try container.decode(Int.self, forKey: .createdAt)
-        createdAt = Date(timeIntervalSince1970: TimeInterval(timestamp) / 1000)
-
-        caption = try container.decode(String.self, forKey: .caption)
-        likes = try container.decode(Int.self, forKey: .likes)
-        comments = try container.decode(Int.self, forKey: .comments)
-        isDeleted = try container.decode(Bool.self, forKey: .isDeleted)
-        privacyLevel = try container.decode(PrivacyLevel.self, forKey: .privacyLevel)
-        lastEditedAt = try container.decode(Date?.self, forKey: .lastEditedAt)
+    func encode(to encoder: Encoder) throws {
+        var container = encoder.container(keyedBy: CodingKeys.self)
+        try container.encode(id, forKey: .id)
+        try container.encode(userId, forKey: .userId)
+        try container.encode(videoURL.absoluteString, forKey: .videoURL)
+        try container.encode(thumbnailURL?.absoluteString, forKey: .thumbnailURL)
+        try container.encode(createdAt, forKey: .createdAt)
+        try container.encode(caption, forKey: .caption)
+        try container.encode(likes, forKey: .likes)
+        try container.encode(comments, forKey: .comments)
+        try container.encode(isDeleted, forKey: .isDeleted)
+        try container.encode(privacyLevel, forKey: .privacyLevel)
+        try container.encode(lastEditedAt, forKey: .lastEditedAt)
     }
 
     // Add direct initializer
@@ -103,8 +103,6 @@ struct Video: Identifiable, Codable, Hashable {
         self.lastEditedAt = lastEditedAt
     }
 
-    // Add any other fields your upload is saving
-
     // Add hash function
     func hash(into hasher: inout Hasher) {
         hasher.combine(id)
diff --git a/ReelAI/Network/NetworkErrorHandler.swift b/ReelAI/Network/NetworkErrorHandler.swift
new file mode 100644
index 0000000..53b6437
--- /dev/null
+++ b/ReelAI/Network/NetworkErrorHandler.swift
@@ -0,0 +1,112 @@
+import Foundation
+
+enum NetworkErrorType {
+    case connectionLost
+    case timeout
+    case serverError
+    case unauthorized
+    case forbidden
+    case notFound
+    case tooManyRequests
+    case serviceUnavailable
+    case unknown
+}
+
+extension Error {
+    var networkErrorType: NetworkErrorType {
+        let nsError = self as NSError
+
+        // Network-related error domains
+        let networkDomains = [
+            NSURLErrorDomain,
+            "kCFErrorDomainCFNetwork"
+        ]
+
+        // Check domain first
+        if networkDomains.contains(nsError.domain) {
+            // Specific network error codes
+            switch nsError.code {
+            case NSURLErrorTimedOut:
+                return .timeout
+            case NSURLErrorCannotConnectToHost,
+                 NSURLErrorNetworkConnectionLost,
+                 NSURLErrorNotConnectedToInternet:
+                return .connectionLost
+            default:
+                return .unknown
+            }
+        }
+
+        // Check HTTP response errors
+        if let httpResponse = nsError.userInfo["NSHTTPURLResponse"] as? HTTPURLResponse {
+            switch httpResponse.statusCode {
+            case 401: return .unauthorized
+            case 403: return .forbidden
+            case 404: return .notFound
+            case 429: return .tooManyRequests
+            case 500...599: return .serviceUnavailable
+            default: return .unknown
+            }
+        }
+
+        return .unknown
+    }
+
+    var isRetryableNetworkError: Bool {
+        switch networkErrorType {
+        case .connectionLost,
+             .timeout,
+             .serviceUnavailable,
+             .tooManyRequests:
+            return true
+        case .serverError,
+             .unauthorized,
+             .forbidden,
+             .notFound,
+             .unknown:
+            return false
+        }
+    }
+}
+
+struct NetworkErrorHandler {
+    static func handle(_ error: Error,
+                       retryAction: (() -> Void)? = nil,
+                       fallbackAction: (() -> Void)? = nil) {
+        let errorType = error.networkErrorType
+
+        // Log the error
+        print("🌐 Network Error: \(errorType)")
+
+        switch errorType {
+        case .connectionLost:
+            // Attempt retry or show offline mode
+            retryAction?()
+        case .timeout:
+            // Retry with exponential backoff
+            retryAction?()
+        case .unauthorized:
+            // Force re-authentication
+            fallbackAction?()
+        case .forbidden, .notFound:
+            // Critical error, require user intervention
+            fallbackAction?()
+        case .tooManyRequests:
+            // Implement rate limiting or wait
+            fallbackAction?()
+        case .serviceUnavailable:
+            // Retry or show maintenance message
+            retryAction?()
+        case .serverError:
+            // Server-side issue, fallback
+            fallbackAction?()
+        case .unknown:
+            // Generic fallback
+            fallbackAction?()
+        }
+    }
+
+    static func shouldRetry(_ error: Error) -> Bool {
+        return error.isRetryableNetworkError
+    }
+}
diff --git a/ReelAI/Network/NetworkMonitor.swift b/ReelAI/Network/NetworkMonitor.swift
new file mode 100644
index 0000000..2cdb7a2
--- /dev/null
+++ b/ReelAI/Network/NetworkMonitor.swift
@@ -0,0 +1,170 @@
+import Foundation
+import Network
+
+/// A class responsible for monitoring network connectivity and status changes.
+/// This class provides real-time updates about network availability and connection type.
+@MainActor
+class NetworkMonitor {
+    /// Represents the current status of the network connection
+    enum NetworkStatus {
+        /// Network is available and functioning
+        case satisfied
+        /// Network is unavailable
+        case unsatisfied
+        /// Network requires a connection to be established
+        case requiresConnection
+        /// Network status cannot be determined
+        case unknown
+    }
+
+    /// Represents the type of network connection
+    enum ConnectionType {
+        /// Wi-Fi connection
+        case wifi
+        /// Cellular connection
+        case cellular
+        /// Wired ethernet connection
+        case ethernet
+        /// Unknown connection type
+        case unknown
+    }
+
+    /// Shared instance for singleton access
+    static let shared = NetworkMonitor()
+
+    private let monitor: NWPathMonitor
+    private let queue = DispatchQueue(label: "NetworkMonitor", qos: .background)
+
+    private var currentStatus: NetworkStatus = .unknown
+    private var currentConnectionType: ConnectionType = .unknown
+    private var statusUpdateHandlers: [(NetworkStatus) -> Void] = []
+    private var connectionTypeHandlers: [(ConnectionType) -> Void] = []
+
+    /// Initializes a new network monitor instance
+    public init() {
+        monitor = NWPathMonitor()
+        setupMonitoring()
+    }
+
+    private func setupMonitoring() {
+        monitor.pathUpdateHandler = { [weak self] path in
+            guard let self = self else { return }
+
+            // Determine network status
+            let status: NetworkStatus
+            switch path.status {
+            case .satisfied:
+                status = .satisfied
+            case .unsatisfied:
+                status = .unsatisfied
+            case .requiresConnection:
+                status = .requiresConnection
+            @unknown default:
+                status = .unknown
+            }
+
+            // Determine connection type
+            let connectionType: ConnectionType
+            if path.usesInterfaceType(.wifi) {
+                connectionType = .wifi
+            } else if path.usesInterfaceType(.cellular) {
+                connectionType = .cellular
+            } else if path.usesInterfaceType(.wiredEthernet) {
+                connectionType = .ethernet
+            } else {
+                connectionType = .unknown
+            }
+
+            // Update on main actor
+            Task { @MainActor in
+                // We already have self from the outer guard
+                self.currentStatus = status
+                self.currentConnectionType = connectionType
+
+                // Create local copies of handlers
+                let handlers = self.statusUpdateHandlers
+                let typeHandlers = self.connectionTypeHandlers
+
+                // Execute handlers
+                handlers.forEach { $0(status) }
+                typeHandlers.forEach { $0(connectionType) }
+            }
+        }
+    }
+
+    func startMonitoring(statusHandler: ((NetworkStatus) -> Void)? = nil) {
+        if let statusHandler = statusHandler {
+            statusUpdateHandlers.append(statusHandler)
+        }
+        monitor.start(queue: queue)
+    }
+
+    func stopMonitoring() {
+        monitor.cancel()
+    }
+
+    func addStatusHandler(_ handler: @escaping (NetworkStatus) -> Void) {
+        statusUpdateHandlers.append(handler)
+    }
+
+    func addConnectionTypeHandler(_ handler: @escaping (ConnectionType) -> Void) {
+        connectionTypeHandlers.append(handler)
+    }
+
+    var isConnected: Bool {
+        return currentStatus == .satisfied
+    }
+
+    var connectionType: ConnectionType {
+        return currentConnectionType
+    }
+
+    @MainActor
+    func checkConnectivity() async -> Bool {
+        return await withCheckedContinuation { continuation in
+            guard let url = URL(string: "https://www.apple.com") else {
+                continuation.resume(returning: false)
+                return
+            }
+
+            var request = URLRequest(url: url)
+            request.timeoutInterval = 5
+
+            let task = URLSession.shared.dataTask(with: request) { _, response, error in
+                let isReachable = (error == nil) &&
+                                  ((response as? HTTPURLResponse)?.statusCode ?? 0) == 200
+                continuation.resume(returning: isReachable)
+            }
+            task.resume()
+        }
+    }
+
+    deinit {
+        // Create a weak reference to monitor to avoid capturing self
+        let monitorRef = monitor
+        Task {
+            await MainActor.run {
+                monitorRef.cancel()
+            }
+        }
+    }
+}
+
+// Extension to provide more detailed network information
+extension NetworkMonitor.ConnectionType {
+    var description: String {
+        switch self {
+        case .wifi: return "Wi-Fi"
+        case .cellular: return "Cellular"
+        case .ethernet: return "Ethernet"
+        case .unknown: return "Unknown"
+        }
+    }
+
+    var isHighSpeed: Bool {
+        switch self {
+        case .wifi, .ethernet: return true
+        case .cellular, .unknown: return false
+        }
+    }
+}
diff --git a/ReelAI/NetworkMonitor.swift b/ReelAI/NetworkMonitor.swift
deleted file mode 100644
index 426439e..0000000
--- a/ReelAI/NetworkMonitor.swift
+++ /dev/null
@@ -1,49 +0,0 @@
-import Foundation
-import Network
-import Combine
-import SwiftUI
-import os
-
-class NetworkMonitor: ObservableObject {
-    static let shared = NetworkMonitor()
-    private let monitor = NWPathMonitor()
-    private let queue = DispatchQueue(label: "NetworkMonitor")
-
-    @Published private(set) var isConnected = true
-    @Published private(set) var isExpensive = false
-    @Published private(set) var isConstrained = false
-    @Published private(set) var connectionType = NWInterface.InterfaceType.other
-
-    private init() {
-        monitor.pathUpdateHandler = { [weak self] path in
-            DispatchQueue.main.async {
-                self?.isConnected = path.status == .satisfied
-                self?.isExpensive = path.isExpensive
-                self?.isConstrained = path.isConstrained
-                self?.connectionType = path.availableInterfaces.first?.type ?? .other
-
-                // Use os.Logger for structured logging.
-                let logger = Logger(subsystem: Bundle.main.bundleIdentifier ?? "ReelAI", category: "NetworkMonitor")
-                logger.info("Network status: \(path.status == .satisfied ? "Connected" : "Disconnected")")
-
-                let connectionTypeString: String = {
-                    guard let type = path.availableInterfaces.first?.type else { return "unknown" }
-                    switch type {
-                    case .wifi: return "wifi"
-                    case .cellular: return "cellular"
-                    case .wiredEthernet: return "ethernet"
-                    case .loopback: return "loopback"
-                    case .other: return "other"
-                    @unknown default: return "unknown"
-                    }
-                }()
-                logger.info("Connection type: \(connectionTypeString)")
-            }
-        }
-        monitor.start(queue: queue)
-    }
-
-    deinit {
-        monitor.cancel()
-    }
-}
diff --git a/ReelAI/Protocols/VideoUploadProtocols.swift b/ReelAI/Protocols/VideoUploadProtocols.swift
new file mode 100644
index 0000000..1c82e7e
--- /dev/null
+++ b/ReelAI/Protocols/VideoUploadProtocols.swift
@@ -0,0 +1,128 @@
+import Foundation
+import UIKit
+import AVFoundation
+
+/// Represents errors that can occur during the video upload process
+public enum PublicUploadError: Error {
+    /// Video processing failed with a specific reason
+    case videoProcessingFailed(reason: String)
+    /// Network is not available for upload
+    case networkUnavailable
+    /// Error occurred while accessing storage
+    case storageError
+    /// General network error occurred
+    case networkError
+    /// Unknown error occurred
+    case unknownError
+
+    public var localizedDescription: String {
+        switch self {
+        case .videoProcessingFailed(let reason):
+            return "Video processing failed: \(reason)"
+        case .networkUnavailable:
+            return "Network is unavailable"
+        case .storageError:
+            return "Storage error occurred"
+        case .networkError:
+            return "Network error occurred"
+        case .unknownError:
+            return "An unknown error occurred"
+        }
+    }
+}
+
+/// Represents errors that can occur during video selection and processing
+public enum VideoPickerError: Error {
+    /// No videos were selected by the user
+    case noVideosSelected
+    /// The selected video format is not supported
+    case invalidVideoFormat
+    /// Video processing failed with a specific reason
+    case processingFailed(reason: String)
+
+    public var localizedDescription: String {
+        switch self {
+        case .noVideosSelected:
+            return "No videos were selected"
+        case .invalidVideoFormat:
+            return "The selected video format is not supported"
+        case .processingFailed(let reason):
+            return "Video processing failed: \(reason)"
+        }
+    }
+}
+
+/// Protocol defining the interface for video upload view models
+@MainActor
+public protocol VideoUploadViewModelProtocol: AnyObject {
+    /// Sets the selected video URLs for upload
+    /// - Parameter urls: Array of URLs representing selected videos
+    func setSelectedVideos(urls: [URL])
+
+    /// Sets an error state in the view model
+    /// - Parameter error: The upload error that occurred
+    func setError(_ error: PublicUploadError)
+
+    /// Initiates the upload process for selected videos
+    func uploadVideos()
+}
+
+/// Default implementation of VideoUploadViewModelProtocol
+@MainActor
+public class DefaultVideoUploadViewModel: VideoUploadViewModelProtocol {
+    /// Initializes a new default video upload view model
+    public init() {}
+
+    public func setSelectedVideos(urls: [URL]) {}
+    public func setError(_ error: PublicUploadError) {}
+    public func uploadVideos() {}
+}
+
+/// Represents the quality level for video processing
+public enum VideoQuality {
+    /// Low quality, smaller file size
+    case low
+    /// Medium quality, balanced file size
+    case medium
+    /// High quality, larger file size
+    case high
+}
+
+/// Represents the current status of a video upload
+public enum UploadStatus {
+    /// Upload is waiting to begin
+    case pending
+    /// Upload is in progress with a progress value
+    case uploading(progress: Double)
+    /// Upload completed successfully with a URL
+    case completed(URL)
+    /// Upload failed with an error
+    case failed(Error)
+}
+
+/// Generates a thumbnail image from a video URL
+/// - Parameter videoURL: The URL of the video
+/// - Returns: An optional UIImage representing the thumbnail, or nil if generation fails
+public func generateThumbnail(for videoURL: URL) async -> UIImage? {
+    let asset = AVURLAsset(url: videoURL)
+    let generator = AVAssetImageGenerator(asset: asset)
+    generator.appliesPreferredTrackTransform = true
+
+    return await withCheckedContinuation { continuation in
+        generator.generateCGImageAsynchronously(
+            for: CMTime(seconds: 1, preferredTimescale: 60)
+        ) { cgImage, time, error in
+            if let error = error {
+                print("❌ Could not generate thumbnail for video: \(error.localizedDescription)")
+                continuation.resume(returning: nil)
+                return
+            }
+
+            if let cgImage = cgImage {
+                continuation.resume(returning: UIImage(cgImage: cgImage))
+            } else {
+                continuation.resume(returning: nil)
+            }
+        }
+    }
+}
diff --git a/ReelAI/ReelAIApp.swift b/ReelAI/ReelAIApp.swift
index d202ef7..a735ebd 100644
--- a/ReelAI/ReelAIApp.swift
+++ b/ReelAI/ReelAIApp.swift
@@ -7,7 +7,7 @@
 
 import SwiftUI
 import FirebaseCore
-import FirebaseDatabase
+import FirebaseAuth
 import os
 
 class AppDelegate: NSObject, UIApplicationDelegate {
@@ -17,13 +17,14 @@ class AppDelegate: NSObject, UIApplicationDelegate {
         _ application: UIApplication,
         didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]? = nil
     ) -> Bool {
+        logger.debug("🚀 Initializing app")
         logger.debug("🔧 Configuring Firebase")
         FirebaseApp.configure()
 
-        // Disable persistence completely
-        Database.database().isPersistenceEnabled = false
+        // Initialize database with persistence
+        _ = FirebaseDatabaseManager.shared
 
-        logger.debug("✅ Firebase configured with persistence disabled")
+        logger.debug("✅ Firebase configured with persistence enabled")
         return true
     }
 }
diff --git a/ReelAI/Services/AuthService.swift b/ReelAI/Services/AuthService.swift
index c093306..c38c25d 100644
--- a/ReelAI/Services/AuthService.swift
+++ b/ReelAI/Services/AuthService.swift
@@ -2,10 +2,15 @@ import FirebaseAuth
 
 protocol AuthServiceProtocol {
     var currentUser: User? { get }
+    func signOut() throws
 }
 
 class FirebaseAuthService: AuthServiceProtocol {
     var currentUser: User? {
         Auth.auth().currentUser
     }
+    
+    func signOut() throws {
+        try Auth.auth().signOut()
+    }
 }
diff --git a/ReelAI/Services/DatabaseManager.swift b/ReelAI/Services/DatabaseManager.swift
index 6653bf4..da401c2 100644
--- a/ReelAI/Services/DatabaseManager.swift
+++ b/ReelAI/Services/DatabaseManager.swift
@@ -1,5 +1,6 @@
 import Foundation
 
+@MainActor
 protocol DatabaseManager {
     func updateProfile(_ profile: UserProfile) async throws
     func fetchProfile(userId: String) async throws -> UserProfile
diff --git a/ReelAI/Services/FirebaseDatabaseManager.swift b/ReelAI/Services/FirebaseDatabaseManager.swift
index 0d80ed5..53babfd 100644
--- a/ReelAI/Services/FirebaseDatabaseManager.swift
+++ b/ReelAI/Services/FirebaseDatabaseManager.swift
@@ -1,154 +1,184 @@
 import FirebaseDatabase
 import os
 
+@MainActor
 final class FirebaseDatabaseManager: DatabaseManager {
-    private let db = Database.database().reference()
+    @MainActor static let shared = FirebaseDatabaseManager()
+    private let db: DatabaseReference
     private let logger = Logger(subsystem: Bundle.main.bundleIdentifier ?? "ReelAI", category: "DatabaseManager")
 
-    func updateProfile(_ profile: UserProfile) async throws {
-        let data = try JSONEncoder().encode(profile)
-        var dict = try JSONSerialization.jsonObject(with: data) as? [String: Any] ?? [:]
-
-        // Ensure required fields
-        dict["id"] = profile.id
-        dict["displayName"] = profile.displayName
-        dict["bio"] = profile.bio
-        dict["socialLinks"] = profile.socialLinks
-        if let photoURL = profile.photoURL?.absoluteString {
-            dict["photoURL"] = photoURL
+    private init() {
+        Database.database().isPersistenceEnabled = true
+        db = Database.database().reference()
+    }
+
+    // Sendable-compliant struct for database updates
+    private struct DatabaseUpdate<T: Encodable & Sendable>: Sendable {
+        let path: String
+        let value: T
+    }
+
+    // Sendable-compliant struct for profile updates
+    private struct ProfileUpdateData: Codable, Sendable {
+        let id: String
+        let displayName: String
+        let bio: String
+        let socialLinks: [UserProfile.SocialLink]
+        let photoURL: String?
+
+        init(from profile: UserProfile) {
+            self.id = profile.id
+            self.displayName = profile.displayName
+            self.bio = profile.bio
+            self.socialLinks = profile.socialLinks
+            self.photoURL = profile.photoURL?.absoluteString
         }
+    }
+
+    // Sendable-compliant structs for video updates
+    private struct VideoUpdateData: Codable, Sendable {
+        let id: String
+        let isDeleted: Bool
+        let lastEditedAt: Int
 
-        try await db.child("users").child(profile.id).updateChildValues(dict)
+        init(id: String, isDeleted: Bool) {
+            self.id = id
+            self.isDeleted = isDeleted
+            self.lastEditedAt = Int(Date().timeIntervalSince1970 * 1000)
+        }
+    }
+
+    private struct VideoCaptionUpdate: Codable, Sendable {
+        let caption: String
+        let lastEditedAt: Int
+
+        init(caption: String) {
+            self.caption = caption.trimmingCharacters(in: .whitespacesAndNewlines)
+            self.lastEditedAt = Int(Date().timeIntervalSince1970 * 1000)
+        }
+    }
+
+    // Helper method for safe JSON conversion
+    @MainActor
+    private func convertToDict<T: Encodable>(_ value: T) throws -> [String: Any] {
+        let data = try JSONEncoder().encode(value)
+        return try JSONSerialization.jsonObject(with: data) as? [String: Any] ?? [:]
+    }
+
+    @MainActor
+    func updateProfile(_ profile: UserProfile) async throws {
+        // Create Sendable update data
+        let updateData = ProfileUpdateData(from: profile)
+        let update = DatabaseUpdate(path: "users/\(profile.id)", value: updateData)
+        let dict = try convertToDict(update.value)
+        try await db.child(update.path).updateChildValues(dict)
     }
 
+    @MainActor
     func fetchProfile(userId: String) async throws -> UserProfile {
         let snapshot = try await db.child("users").child(userId).getData()
         guard var data = snapshot.value as? [String: Any] else {
             throw DatabaseError.invalidData
         }
 
+        // Since we're already on the main actor, we can do this directly
         // Ensure all required fields exist with defaults
         data["id"] = userId
         if data["displayName"] == nil { data["displayName"] = "New User" }
         if data["bio"] == nil { data["bio"] = "" }
         if data["socialLinks"] == nil { data["socialLinks"] = [] }
 
+        // Explicitly handle photoURL
+        if let photoURLString = data["photoURL"] as? String {
+            data["photoURL"] = photoURLString
+            print("🔍 Fetched Photo URL from Database: \(photoURLString)")
+        } else {
+            print("⚠️ No Photo URL found in database")
+            data["photoURL"] = NSNull()
+        }
+
         let jsonData = try JSONSerialization.data(withJSONObject: data)
         return try JSONDecoder().decode(UserProfile.self, from: jsonData)
     }
 
+    @MainActor
     func updateVideo(_ video: Video) async throws {
-        let data = try JSONEncoder().encode(video)
-        let dict = try JSONSerialization.jsonObject(with: data) as? [String: Any] ?? [:]
-        try await db.child("videos").child(video.id).updateChildValues(dict)
+        let update = DatabaseUpdate(path: "videos/\(video.id)", value: video)
+        let dict = try convertToDict(update.value)
+        try await db.child(update.path).updateChildValues(dict)
     }
 
     func deleteVideo(id: String) async throws {
         try await db.child("videos").child(id).removeValue()
     }
 
+    @MainActor
     func softDeleteVideo(_ videoId: String) async throws {
         logger.debug("🗑️ DatabaseManager: Starting soft delete for video: \(videoId)")
 
-        // Get current state first
-        let snapshot = try await db.child("videos/\(videoId)").getData()
-        if let value = snapshot.value {
-            logger.debug("📥 DatabaseManager: Current state - \(String(describing: value))")
-        }
-
-        try await db.child("videos/\(videoId)").updateChildValues([
-            "isDeleted": true
-        ])
-
-        // Verify the update
-        let updatedSnapshot = try await db.child("videos/\(videoId)").getData()
-        if let value = updatedSnapshot.value {
-            logger.debug("📤 DatabaseManager: Updated state - \(String(describing: value))")
-        }
+        let updateData = VideoUpdateData(id: videoId, isDeleted: true)
+        let update = DatabaseUpdate(path: "videos/\(videoId)", value: updateData)
+        let dict = try convertToDict(update.value)
+        try await db.child(update.path).updateChildValues(dict)
 
         logger.debug("✅ DatabaseManager: Video marked as deleted in database")
     }
 
+    @MainActor
     func restoreVideo(_ videoId: String) async throws {
         logger.debug("🔄 DatabaseManager: Starting restore for video: \(videoId)")
 
-        // Get current state first
-        let snapshot = try await db.child("videos/\(videoId)").getData()
-        if let value = snapshot.value {
-            logger.debug("📥 DatabaseManager: Current state - \(String(describing: value))")
-        }
-
-        let updates: [String: Any] = [
-            "isDeleted": false,
-            "lastEditedAt": Int(Date().timeIntervalSince1970 * 1000)
-        ]
-        try await db.child("videos/\(videoId)").updateChildValues(updates)
-
-        // Verify the update
-        let updatedSnapshot = try await db.child("videos/\(videoId)").getData()
-        if let value = updatedSnapshot.value {
-            logger.debug("📤 DatabaseManager: Updated state - \(String(describing: value))")
-        }
+        let updateData = VideoUpdateData(id: videoId, isDeleted: false)
+        let update = DatabaseUpdate(path: "videos/\(videoId)", value: updateData)
+        let dict = try convertToDict(update.value)
+        try await db.child(update.path).updateChildValues(dict)
 
         logger.debug("✅ DatabaseManager: Video restored in database")
     }
 
+    @MainActor
     func updateVideoPrivacy(_ videoId: String, privacyLevel: Video.PrivacyLevel) async throws {
         logger.debug("🔒 Attempting to update privacy for video: \(videoId) to \(String(describing: privacyLevel))")
 
-        // Create a Video object with just the privacy update
         let update = VideoPrivacyUpdate(
             id: videoId,
             privacyLevel: privacyLevel,
             lastEditedAt: Date()
         )
-
-        let data = try JSONEncoder().encode(update)
-        let dict = try JSONSerialization.jsonObject(with: data) as? [String: Any] ?? [:]
+        let dict = try convertToDict(update)
         try await db.child("videos").child(videoId).updateChildValues(dict)
 
         logger.debug("✅ Privacy updated in database")
     }
 
+    @MainActor
     func updateVideoMetadata(_ videoId: String, caption: String) async throws {
         logger.debug("📝 Attempting to update caption for video: \(videoId)")
-        let updates: [String: Any] = [
-            "caption": caption.trimmingCharacters(in: .whitespacesAndNewlines),
-            "lastEditedAt": Int(Date().timeIntervalSince1970 * 1000)
-        ]
-        try await db.child("videos/\(videoId)").updateChildValues(updates)
+
+        let updateData = VideoCaptionUpdate(caption: caption)
+        let update = DatabaseUpdate(path: "videos/\(videoId)", value: updateData)
+        let dict = try convertToDict(update.value)
+        try await db.child(update.path).updateChildValues(dict)
+
         logger.debug("✅ Caption updated in database")
     }
 
+    @MainActor
     func fetchVideos(limit: Int, after key: String?) async throws -> [Video] {
         logger.debug("📥 Fetching videos from database")
 
-        // Create the query
         let query = db.child("videos")
             .queryOrdered(byChild: "timestamp")
             .queryLimited(toLast: UInt(limit))
 
-        // Disable cache for this reference
         db.child("videos").keepSynced(false)
-
-        // Get fresh data from server
         let snapshot = try await query.getData()
-        logger.debug("📤 Got \(snapshot.childrenCount) videos from database")
 
+        // Since we're already on the main actor, we can do this directly
         guard let dict = snapshot.value as? [String: [String: Any]] else {
             return []
         }
 
-        // Log each video's state
-        for (id, data) in dict {
-            logger.debug("""
-            🎥 Video in database:
-            ID: \(id)
-            Deleted: \(data["isDeleted"] as? Bool ?? false)
-            Privacy: \(data["privacyLevel"] as? String ?? "public")
-            """)
-        }
-
         return try dict.compactMap { id, data in
             var mutableData = data
             mutableData["id"] = id
@@ -162,8 +192,8 @@ final class FirebaseDatabaseManager: DatabaseManager {
     }
 }
 
-// Add this struct
-private struct VideoPrivacyUpdate: Codable {
+// Make VideoPrivacyUpdate Sendable
+private struct VideoPrivacyUpdate: Codable, Sendable {
     let id: String
     let privacyLevel: Video.PrivacyLevel
     let lastEditedAt: Date
diff --git a/ReelAI/Services/FirebaseStorageManager.swift b/ReelAI/Services/FirebaseStorageManager.swift
index 5877a85..3fbf47c 100644
--- a/ReelAI/Services/FirebaseStorageManager.swift
+++ b/ReelAI/Services/FirebaseStorageManager.swift
@@ -2,12 +2,53 @@ import Foundation
 import FirebaseStorage
 import FirebaseAuth
 
+@MainActor
 final class FirebaseStorageManager: StorageManager {
     private let storage = Storage.storage().reference()
+    private let maxRetries = 3
+    private let baseRetryDelay: TimeInterval = 1.0
 
-    enum StorageError: Error {
+    enum StorageError: Error, LocalizedError {
         case notAuthenticated
         case uploadFailed(Error)
+        case invalidUser
+        case networkError
+        case uploadCancelled
+
+        var errorDescription: String? {
+            switch self {
+            case .notAuthenticated:
+                return "User is not authenticated"
+            case .uploadFailed(let error):
+                return "Upload failed: \(error.localizedDescription)"
+            case .invalidUser:
+                return "Invalid user ID"
+            case .networkError:
+                return "Network connection failed"
+            case .uploadCancelled:
+                return "Upload was cancelled"
+            }
+        }
+    }
+
+    private func exponentialBackoff(attempt: Int) -> TimeInterval {
+        return baseRetryDelay * pow(2.0, Double(attempt))
+    }
+
+    private func shouldRetry(error: Error) -> Bool {
+        let nsError = error as NSError
+
+        // Common network-related error codes to retry
+        let retryErrorCodes = [
+            -1200,  // SSL error
+            -1009,  // No internet connection
+            -1004,  // Could not connect to server
+            -1001   // Timeout
+        ]
+
+        return retryErrorCodes.contains(nsError.code) ||
+               nsError.domain == NSURLErrorDomain ||
+               nsError.domain == "kCFErrorDomainCFNetwork"
     }
 
     func uploadProfilePhoto(_ data: Data, userId: String) async throws -> URL {
@@ -20,24 +61,76 @@ final class FirebaseStorageManager: StorageManager {
             throw StorageError.notAuthenticated
         }
 
-        // Changed path to match storage rules structure
-        let filename = "\(UUID().uuidString).jpg"
+        // Detailed data validation
+        print("📊 Image data details:")
+        print("- Size: \(data.count) bytes")
+        print("- Is empty: \(data.isEmpty)")
+
+        guard !data.isEmpty else {
+            print("❌ Image data is empty")
+            throw StorageError.uploadFailed(NSError(domain: "PhotoUpload", code: -1, userInfo: [NSLocalizedDescriptionKey: "Empty image data"]))
+        }
+
+        // Consistent filename for profile photo
+        let filename = "profile.jpg"
         let photoRef = storage.child("profile_photos/\(userId)/\(filename)")
 
-        let metadata = StorageMetadata()
-        metadata.contentType = "image/jpeg"
+        var lastError: Error?
+        for attempt in 0..<maxRetries {
+            do {
+                let metadata = StorageMetadata()
+                metadata.contentType = "image/jpeg"
 
-        do {
-            print("📤 Starting upload to: \(photoRef.fullPath)")
-            _ = try await photoRef.putDataAsync(data, metadata: metadata)
-            print("✅ Upload successful")
-            let url = try await photoRef.downloadURL()
-            print("📍 Download URL: \(url)")
-            return url
-        } catch {
-            print("❌ Upload failed with error: \(error)")
+                print("📤 Upload attempt \(attempt + 1): \(photoRef.fullPath)")
+
+                _ = try await photoRef.putDataAsync(data, metadata: metadata)
+                let url = try await photoRef.downloadURL()
+
+                print("✅ Upload successful: \(url)")
+                print("📍 Download URL: \(url)")
+                print("📍 URL String: \(url.absoluteString)")
+
+                return url
+            } catch {
+                lastError = error
+
+                if !shouldRetry(error: error) {
+                    break
+                }
+
+                print("⏳ Retrying upload in \(exponentialBackoff(attempt: attempt)) seconds")
+                try? await Task.sleep(nanoseconds: UInt64(exponentialBackoff(attempt: attempt) * 1_000_000_000))
+            }
+        }
+
+        // Log final error details
+        if let error = lastError {
+            print("❌ Upload failed after \(maxRetries) attempts")
+            print("- Error type: \(type(of: error))")
             print("- Error description: \(error.localizedDescription)")
-            throw StorageError.uploadFailed(error)
+
+            let nsError = error as NSError
+            print("- NS Error domain: \(nsError.domain)")
+            print("- NS Error code: \(nsError.code)")
+            print("- NS Error userInfo: \(nsError.userInfo)")
+        }
+
+        throw lastError ?? StorageError.uploadFailed(StorageError.networkError)
+    }
+
+    private func deleteExistingProfilePhoto(for userId: String) async throws {
+        let profilePhotoRef = storage.child("profile_photos/\(userId)/profile.jpg")
+
+        do {
+            try await profilePhotoRef.delete()
+            print("✅ Existing profile photo deleted successfully")
+        } catch let error as NSError {
+            // If the error is that the file doesn't exist, we can ignore it
+            if error.domain == "FIRStorageErrorDomain" && error.code == -100 {
+                print("ℹ️ No existing profile photo found")
+                return
+            }
+            throw error
         }
     }
 
@@ -46,8 +139,35 @@ final class FirebaseStorageManager: StorageManager {
         let metadata = StorageMetadata()
         metadata.contentType = "video/mp4"
 
-        _ = try await videoRef.putFileAsync(from: url, metadata: metadata)
-        return try await videoRef.downloadURL()
+        var lastError: Error?
+        for attempt in 0..<maxRetries {
+            do {
+                print("📤 Video upload attempt \(attempt + 1): \(name)")
+                _ = try await videoRef.putFileAsync(from: url, metadata: metadata)
+                let downloadURL = try await videoRef.downloadURL()
+
+                print("✅ Video upload successful: \(downloadURL)")
+                return downloadURL
+            } catch {
+                lastError = error
+
+                if !shouldRetry(error: error) {
+                    break
+                }
+
+                print("⏳ Retrying video upload in \(exponentialBackoff(attempt: attempt)) seconds")
+                try? await Task.sleep(nanoseconds: UInt64(exponentialBackoff(attempt: attempt) * 1_000_000_000))
+            }
+        }
+
+        // Log final error details
+        if let error = lastError {
+            print("❌ Video upload failed after \(maxRetries) attempts")
+            print("- Error type: \(type(of: error))")
+            print("- Error description: \(error.localizedDescription)")
+        }
+
+        throw lastError ?? StorageError.uploadFailed(StorageError.networkError)
     }
 
     func uploadThumbnail(_ data: Data, for videoId: String) async throws -> URL {
@@ -55,8 +175,35 @@ final class FirebaseStorageManager: StorageManager {
         let metadata = StorageMetadata()
         metadata.contentType = "image/jpeg"
 
-        _ = try await thumbRef.putDataAsync(data, metadata: metadata)
-        return try await thumbRef.downloadURL()
+        var lastError: Error?
+        for attempt in 0..<maxRetries {
+            do {
+                print("📤 Thumbnail upload attempt \(attempt + 1): \(videoId)")
+                _ = try await thumbRef.putDataAsync(data, metadata: metadata)
+                let downloadURL = try await thumbRef.downloadURL()
+
+                print("✅ Thumbnail upload successful: \(downloadURL)")
+                return downloadURL
+            } catch {
+                lastError = error
+
+                if !shouldRetry(error: error) {
+                    break
+                }
+
+                print("⏳ Retrying thumbnail upload in \(exponentialBackoff(attempt: attempt)) seconds")
+                try? await Task.sleep(nanoseconds: UInt64(exponentialBackoff(attempt: attempt) * 1_000_000_000))
+            }
+        }
+
+        // Log final error details
+        if let error = lastError {
+            print("❌ Thumbnail upload failed after \(maxRetries) attempts")
+            print("- Error type: \(type(of: error))")
+            print("- Error description: \(error.localizedDescription)")
+        }
+
+        throw lastError ?? StorageError.uploadFailed(StorageError.networkError)
     }
 
     func getDownloadURL(for path: String) async throws -> URL {
diff --git a/ReelAI/Services/StorageManager.swift b/ReelAI/Services/StorageManager.swift
index ee0ce7f..99cff93 100644
--- a/ReelAI/Services/StorageManager.swift
+++ b/ReelAI/Services/StorageManager.swift
@@ -1,6 +1,7 @@
 import Foundation
 import FirebaseStorage
 
+@MainActor
 protocol StorageManager {
     func uploadProfilePhoto(_ data: Data, userId: String) async throws -> URL
     func uploadVideo(_ url: URL, name: String) async throws -> URL
diff --git a/ReelAI/VideoCache/VideoCacheManager.swift b/ReelAI/VideoCache/VideoCacheManager.swift
index e99505c..769e4de 100644
--- a/ReelAI/VideoCache/VideoCacheManager.swift
+++ b/ReelAI/VideoCache/VideoCacheManager.swift
@@ -4,30 +4,47 @@ import UIKit
 
 extension Notification.Name {
     static let videoCacheCleared = Notification.Name("videoCacheCleared")
+    static let videoCacheSizeChanged = Notification.Name("videoCacheSizeChanged")
 }
 
 actor VideoCacheManager {
-    private let logger = Logger(subsystem: Bundle.main.bundleIdentifier ?? "ReelAI", category: "VideoCacheManager")
     private let fileManager: FileManager
     private let videoCacheDirectory: URL
     private let thumbnailCacheDirectory: URL
-    private let maxCacheSize: UInt64 = 500 * 1024 * 1024  // 500MB default
-    private let maxThumbnailCacheSize: UInt64 = 50 * 1024 * 1024  // 50MB default
+    private var cacheMetadata: [String: CacheEntry] = [:]
+    private let logger = Logger(subsystem: "com.reelai.videocache", category: "VideoCacheManager")
     
-    // Use actor-isolated property for thread safety
+    // Configurable cache limits
+    private let maxCacheSize: UInt64 = 1 * 1024 * 1024 * 1024  // 1GB for videos
+    private let maxThumbnailCacheSize: UInt64 = 100 * 1024 * 1024  // 100MB for thumbnails
+    private let maxCacheAge: TimeInterval = 7 * 24 * 60 * 60  // 1 week
+    
+    // Tracking cache metadata
     private var hasLoggedInitialStatus = false
 
+    // Cache entry to track metadata
+    private struct CacheEntry: Codable {
+        let id: String
+        let cachedAt: Date
+        let fileSize: Int64
+        var lastAccessedAt: Date
+    }
+
+    // Static shared instance with lazy initialization
     static let shared: VideoCacheManager = {
         do {
             return try VideoCacheManager()
         } catch {
-            fatalError("Failed to initialize VideoCacheManager: \(error)")
+            // Log the error and provide a fallback
+            print("❌ Failed to initialize VideoCacheManager: \(error)")
+            fatalError("Could not initialize VideoCacheManager")
         }
     }()
 
+    // Designated initializer
     private init() throws {
-        self.fileManager = FileManager.default
-
+        self.fileManager = .default
+        
         // Use the app support directory for persistent cache
         guard let appSupportDir = fileManager.urls(for: .applicationSupportDirectory, in: .userDomainMask).first else {
             throw VideoCacheError.failedToGetSupportDirectory
@@ -36,49 +53,140 @@ actor VideoCacheManager {
         self.videoCacheDirectory = appSupportDir.appendingPathComponent("VideoCache", isDirectory: true)
         self.thumbnailCacheDirectory = appSupportDir.appendingPathComponent("ThumbnailCache", isDirectory: true)
 
-        // Create cache directories if they don't exist
-        if !fileManager.fileExists(atPath: videoCacheDirectory.path) {
-            try fileManager.createDirectory(at: videoCacheDirectory, withIntermediateDirectories: true)
+        // Create cache directories
+        try Self.createDirectoriesNonIsolated(
+            directories: [videoCacheDirectory, thumbnailCacheDirectory], 
+            fileManager: fileManager
+        )
+
+        // Load cache metadata
+        self.cacheMetadata = try Self.loadCacheMetadataNonIsolated(
+            metadataURL: videoCacheDirectory.appendingPathComponent("cache_metadata.json"), 
+            fileManager: fileManager
+        )
+
+        // Start periodic maintenance
+        Task { [weak self] in
+            try? await self?.performCacheMaintenance()
         }
+    }
 
-        if !fileManager.fileExists(atPath: thumbnailCacheDirectory.path) {
-            try fileManager.createDirectory(at: thumbnailCacheDirectory, withIntermediateDirectories: true)
+    // Static method for non-isolated directory creation
+    private static func createDirectoriesNonIsolated(
+        directories: [URL], 
+        fileManager: FileManager
+    ) throws {
+        for directory in directories {
+            if !fileManager.fileExists(atPath: directory.path) {
+                try fileManager.createDirectory(
+                    at: directory, 
+                    withIntermediateDirectories: true, 
+                    attributes: nil
+                )
+            }
         }
+    }
 
-        // Add a .nomedia file to prevent thumbnails from showing in photo galleries
-        let nomediaPath = thumbnailCacheDirectory.appendingPathComponent(".nomedia")
-        if !fileManager.fileExists(atPath: nomediaPath.path) {
-            try Data().write(to: nomediaPath)
+    // Static method for non-isolated metadata loading
+    private static func loadCacheMetadataNonIsolated(
+        metadataURL: URL, 
+        fileManager: FileManager
+    ) throws -> [String: CacheEntry] {
+        guard fileManager.fileExists(atPath: metadataURL.path) else { 
+            // Initialize empty metadata if file doesn't exist
+            return [:]
         }
+        
+        let data = try Data(contentsOf: metadataURL)
+        return try JSONDecoder().decode([String: CacheEntry].self, from: data)
+    }
 
-        // Log initial status in next run loop to ensure proper initialization
-        Task { [self] in
-            await checkAndLogInitialStatus()
-        }
+    // Public async initialization method
+    static func initialize() async throws -> VideoCacheManager {
+        return try VideoCacheManager()
     }
 
-    private func checkAndLogInitialStatus() async {
-        guard !hasLoggedInitialStatus else { return }
-        hasLoggedInitialStatus = true
+    private func performCacheMaintenance() async throws {
+        let currentTime = Date()
         
-        let message = "📱 VideoCacheManager initialized"
-        print(message)
-        logger.info("\(message)")
-        logCacheStatus()
+        // Remove expired entries
+        var removedEntries = 0
+        for (id, entry) in cacheMetadata {
+            if currentTime.timeIntervalSince(entry.cachedAt) > maxCacheAge {
+                try? removeFile(at: getCacheURL(forIdentifier: id, fileExtension: "mp4"))
+                cacheMetadata.removeValue(forKey: id)
+                removedEntries += 1
+            }
+        }
+
+        // Enforce total cache size limit
+        try await enforceMaxCacheSize()
+
+        // Save updated metadata
+        try saveCacheMetadata()
+
+        logger.info("Cache maintenance: Removed \(removedEntries) expired entries")
     }
 
-    enum VideoCacheError: Error {
-        case failedToGetSupportDirectory
-        case failedToCreateDirectory
-        case failedToSaveFile
-        case failedToLoadFile
-        case fileNotFound
-        case invalidData
-        case downloadFailed
-        case thumbnailConversionFailed
+    private func enforceMaxCacheSize() async throws {
+        // Sort entries by last access time, oldest first
+        let sortedEntries = cacheMetadata.values.sorted { $0.lastAccessedAt < $1.lastAccessedAt }
+        var currentCacheSize = try await calculateSize(of: videoCacheDirectory)
+
+        for entry in sortedEntries {
+            guard currentCacheSize > maxCacheSize else { break }
+            
+            let fileURL = getCacheURL(forIdentifier: entry.id, fileExtension: "mp4")
+            try? removeFile(at: fileURL)
+            cacheMetadata.removeValue(forKey: entry.id)
+            
+            currentCacheSize -= UInt64(entry.fileSize)
+        }
     }
 
-    // MARK: - Helper Methods
+    func cacheVideo(from url: URL, withIdentifier id: String) throws -> URL {
+        let cachedFileURL = getCacheURL(forIdentifier: id, fileExtension: "mp4")
+
+        // Return cached version if exists and update access time
+        if fileExists(at: cachedFileURL) {
+            updateCacheEntryAccessTime(for: id)
+            return cachedFileURL
+        }
+
+        // Perform actual caching (synchronous)
+        let videoData = try Data(contentsOf: url)
+        try saveData(videoData, to: cachedFileURL)
+        
+        // Update cache metadata
+        let entry = CacheEntry(
+            id: id, 
+            cachedAt: Date(), 
+            fileSize: Int64(videoData.count), 
+            lastAccessedAt: Date()
+        )
+        cacheMetadata[id] = entry
+        
+        try saveCacheMetadata()
+        
+        // Notify of cache size change
+        DispatchQueue.main.async {
+            NotificationCenter.default.post(name: .videoCacheSizeChanged, object: nil)
+        }
+
+        logger.debug("Cached video for id: \(id)")
+        return cachedFileURL
+    }
+
+    private func updateCacheEntryAccessTime(for id: String) {
+        guard var entry = cacheMetadata[id] else { return }
+        entry.lastAccessedAt = Date()
+        cacheMetadata[id] = entry
+        
+        // Periodically save metadata to avoid constant writes
+        Task {
+            try? saveCacheMetadata()
+        }
+    }
 
     private func getCacheURL(forIdentifier identifier: String, fileExtension: String) -> URL {
         return videoCacheDirectory.appendingPathComponent("\(identifier).\(fileExtension)")
@@ -92,12 +200,6 @@ actor VideoCacheManager {
         return fileManager.fileExists(atPath: url.path)
     }
 
-    private func createDirectory(at url: URL) throws {
-        if !fileExists(at: url) {
-            try fileManager.createDirectory(at: url, withIntermediateDirectories: true)
-        }
-    }
-
     private func saveData(_ data: Data, to url: URL) throws {
         try data.write(to: url)
     }
@@ -126,24 +228,6 @@ actor VideoCacheManager {
         }
     }
 
-    // MARK: - Public Methods
-
-    func cacheVideo(from url: URL, withIdentifier id: String) async throws -> URL {
-        let cachedFileURL = getCacheURL(forIdentifier: id, fileExtension: "mp4")
-
-        // Return cached version if exists
-        if fileExists(at: cachedFileURL) {
-            return cachedFileURL
-        }
-
-        // Download and cache
-        let (downloadURL, _) = try await URLSession.shared.download(from: url)
-        try moveFileToCache(from: downloadURL, to: cachedFileURL)
-
-        logger.debug("Cached video for id: \(id)")
-        return cachedFileURL
-    }
-
     func getCachedThumbnail(withIdentifier id: String) async -> UIImage? {
         let cachedFileURL = getThumbnailCacheURL(forIdentifier: id, fileExtension: "jpg")
 
@@ -263,7 +347,10 @@ actor VideoCacheManager {
             """
             
             // Only log once
-            logger.info("\(message)")
+            if !hasLoggedInitialStatus {
+                logger.info("\(message)")
+                hasLoggedInitialStatus = true
+            }
         }
     }
     
@@ -279,4 +366,21 @@ actor VideoCacheManager {
             return total + UInt64(resourceValues.fileSize ?? 0)
         }
     }
+
+    private func saveCacheMetadata() throws {
+        let metadataURL = videoCacheDirectory.appendingPathComponent("cache_metadata.json")
+        let data = try JSONEncoder().encode(cacheMetadata)
+        try data.write(to: metadataURL)
+    }
+
+    enum VideoCacheError: Error {
+        case failedToGetSupportDirectory
+        case failedToCreateDirectory
+        case failedToSaveFile
+        case failedToLoadFile
+        case fileNotFound
+        case invalidData
+        case downloadFailed
+        case thumbnailConversionFailed
+    }
 }
diff --git a/ReelAI/VideoPicker.swift b/ReelAI/VideoPicker.swift
index 97474c0..2ee3898 100644
--- a/ReelAI/VideoPicker.swift
+++ b/ReelAI/VideoPicker.swift
@@ -1,86 +1,108 @@
 import SwiftUI
 import PhotosUI
 import AVFoundation
-import UniformTypeIdentifiers  // Add back for UTType
+import UniformTypeIdentifiers
+import Foundation
 
-struct VideoPicker: UIViewControllerRepresentable {
-    @ObservedObject var viewModel: VideoUploadViewModel
+// Local import of protocols
+import struct Foundation.URL
+import class UIKit.UIImage
 
-    func makeUIViewController(context: Context) -> PHPickerViewController {
-        var config = PHPickerConfiguration(photoLibrary: .shared())
-        config.selectionLimit = 1
-        config.filter = .videos
+public struct VideoPicker: UIViewControllerRepresentable {
+    @Binding var selectedVideoURLs: [URL]
+    private let viewModelWrapper: VideoUploadViewModelProtocol
 
-        let picker = PHPickerViewController(configuration: config)
+    public init(selectedVideoURLs: Binding<[URL]>, viewModel: VideoUploadViewModelProtocol) {
+        self._selectedVideoURLs = selectedVideoURLs
+        self.viewModelWrapper = viewModel
+    }
+
+    public func makeUIViewController(context: Context) -> PHPickerViewController {
+        var configuration = PHPickerConfiguration()
+        configuration.filter = .videos
+        configuration.selectionLimit = 0 // Allow multiple selections
+
+        let picker = PHPickerViewController(configuration: configuration)
         picker.delegate = context.coordinator
         return picker
     }
 
-    func updateUIViewController(_ uiViewController: PHPickerViewController, context: Context) {}
+    public func updateUIViewController(_ uiViewController: PHPickerViewController, context: Context) {}
 
-    func makeCoordinator() -> Coordinator {
-        Coordinator(parent: self)
+    public func makeCoordinator() -> Coordinator {
+        Coordinator(self)
     }
 
-    class Coordinator: NSObject, PHPickerViewControllerDelegate {
-        let parent: VideoPicker
+    public class Coordinator: NSObject, PHPickerViewControllerDelegate {
+        private var parent: VideoPicker
 
-        init(parent: VideoPicker) {
+        public init(_ parent: VideoPicker) {
             self.parent = parent
         }
 
-        func picker(_ picker: PHPickerViewController, didFinishPicking results: [PHPickerResult]) {
+        public func picker(_ picker: PHPickerViewController, didFinishPicking results: [PHPickerResult]) {
             picker.dismiss(animated: true)
             print("📱 VideoPicker: Finished picking, results count: \(results.count)")
 
-            guard let provider = results.first?.itemProvider else {
-                print("❌ VideoPicker: No provider available")
-                parent.viewModel.setError("No video selected")
+            guard !results.isEmpty else {
+                print("❌ VideoPicker: No videos selected")
+                self.parent.viewModelWrapper.setError(.videoProcessingFailed(reason: "No videos selected"))
                 return
             }
 
-            print("📱 VideoPicker: Got provider, checking if file is a video")
-            if provider.hasItemConformingToTypeIdentifier(UTType.movie.identifier) {
-                print("📱 VideoPicker: Loading video file")
-                provider.loadFileRepresentation(forTypeIdentifier: UTType.movie.identifier) { url, error in
-                    if let error = error {
-                        print("❌ VideoPicker: Error loading file: \(error.localizedDescription)")
-                        Task { @MainActor in
-                            self.parent.viewModel.setError(error.localizedDescription)
-                        }
-                        return
-                    }
+            var selectedVideoURLs: [URL] = []
 
-                    guard let url = url else {
-                        print("❌ VideoPicker: URL is nil")
-                        Task { @MainActor in
-                            self.parent.viewModel.setError("Could not load video")
-                        }
-                        return
-                    }
+            let group = DispatchGroup()
+            let queue = DispatchQueue(label: "video-picker-queue")
 
-                    print("📱 VideoPicker: Got URL: \(url.path)")
-                    // Copy to temporary location
-                    let tempURL = FileManager.default.temporaryDirectory
-                        .appendingPathComponent(UUID().uuidString)
-                        .appendingPathExtension("mp4")
-
-                    do {
-                        try FileManager.default.copyItem(at: url, to: tempURL)
-                        print("📱 VideoPicker: Copied to temp URL: \(tempURL.path)")
-                        Task { @MainActor in
-                            self.parent.viewModel.setSelectedVideo(url: tempURL)
-                        }
-                    } catch {
-                        print("❌ VideoPicker: Error copying file: \(error.localizedDescription)")
-                        Task { @MainActor in
-                            self.parent.viewModel.setError("Could not copy video: \(error.localizedDescription)")
+            for provider in results {
+                group.enter()
+                queue.async {
+                    // Use itemProvider's typeIdentifiers to check for video
+                    if provider.itemProvider.hasItemConformingToTypeIdentifier(UTType.movie.identifier) {
+                        provider.itemProvider.loadItem(forTypeIdentifier: UTType.movie.identifier, options: nil) { (urlOrData, error) in
+                            defer { group.leave() }
+
+                            guard error == nil else {
+                                print("❌ Error loading video: \(error?.localizedDescription ?? "Unknown error")")
+                                return
+                            }
+
+                            var videoURL: URL?
+
+                            if let url = urlOrData as? URL {
+                                videoURL = url
+                            } else if let data = urlOrData as? Data,
+                                      let tempDir = try? FileManager.default.url(for: .itemReplacementDirectory, in: .userDomainMask, appropriateFor: nil, create: true) {
+                                let tempFileURL = tempDir.appendingPathComponent(UUID().uuidString).appendingPathExtension("mp4")
+                                do {
+                                    try data.write(to: tempFileURL)
+                                    videoURL = tempFileURL
+                                } catch {
+                                    print("❌ Error writing temp video file: \(error.localizedDescription)")
+                                }
+                            }
+
+                            if let url = videoURL {
+                                selectedVideoURLs.append(url)
+                            }
                         }
+                    } else {
+                        group.leave()
                     }
                 }
-            } else {
-                print("❌ VideoPicker: Provider cannot load URL")
-                parent.viewModel.setError("Selected file is not a video")
+            }
+
+            group.notify(queue: .main) {
+                if selectedVideoURLs.isEmpty {
+                    print("❌ VideoPicker: No valid videos selected")
+                    self.parent.viewModelWrapper.setError(.videoProcessingFailed(reason: "No valid videos found"))
+                } else {
+                    print("📱 VideoPicker: Selected \(selectedVideoURLs.count) videos")
+                    self.parent.selectedVideoURLs = selectedVideoURLs
+                    self.parent.viewModelWrapper.setSelectedVideos(urls: selectedVideoURLs)
+                    self.parent.viewModelWrapper.uploadVideos()
+                }
             }
         }
     }
@@ -89,6 +111,6 @@ struct VideoPicker: UIViewControllerRepresentable {
 #Preview {
     Color.clear // VideoPicker needs to be presented in a sheet
         .sheet(isPresented: .constant(true)) {
-            VideoPicker(viewModel: VideoUploadViewModel())
+            VideoPicker(selectedVideoURLs: .constant([]), viewModel: DefaultVideoUploadViewModel())
         }
 }
diff --git a/ReelAI/ViewModels/EditProfileViewModel.swift b/ReelAI/ViewModels/EditProfileViewModel.swift
index a42c57a..4ddd6fc 100644
--- a/ReelAI/ViewModels/EditProfileViewModel.swift
+++ b/ReelAI/ViewModels/EditProfileViewModel.swift
@@ -1,5 +1,6 @@
+import Foundation
 import SwiftUI
-import FirebaseStorage
+import FirebaseAuth
 
 @MainActor
 final class EditProfileViewModel: ObservableObject {
@@ -9,11 +10,19 @@ final class EditProfileViewModel: ObservableObject {
 
     private let storage: StorageManager
     private let database: DatabaseManager
+    private let authService: FirebaseAuthService
+    private let databaseManager: DatabaseManager
 
-    init(profile: UserProfile, storage: StorageManager, database: DatabaseManager) {
+    init(profile: UserProfile, 
+         storage: StorageManager, 
+         database: DatabaseManager, 
+         authService: FirebaseAuthService, 
+         databaseManager: DatabaseManager) {
         self.profile = profile
         self.storage = storage
         self.database = database
+        self.authService = authService
+        self.databaseManager = databaseManager
     }
 
     func updateProfile() async throws {
@@ -26,32 +35,72 @@ final class EditProfileViewModel: ObservableObject {
                 throw ValidationError.displayNameTooShort
             }
 
+            print("📝 Updating profile: \(profile)")
             try await database.updateProfile(profile)
+            print("✅ Profile update successful")
         } catch {
+            print("❌ Profile update failed: \(error)")
             self.error = error
             throw error
         }
     }
 
     func updateProfilePhoto(_ imageData: Data) async throws {
+        guard let userId = authService.currentUser?.uid else {
+            print("❌ No user ID")
+            throw ProfileError.notAuthenticated
+        }
+
         isLoading = true
         defer { isLoading = false }
 
         do {
-            // Validate image data
-            guard !imageData.isEmpty, imageData.count < 5_000_000 else { // 5MB limit
-                throw ValidationError.invalidImageData
+            print("📸 Uploading profile photo")
+            print("📊 Image data size: \(imageData.count) bytes")
+            
+            let url = try await storage.uploadProfilePhoto(imageData, userId: userId)
+            
+            print("🖼️ Photo uploaded successfully")
+            print("📍 Photo URL: \(url)")
+            
+            // Immediately update the local profile with the new photo URL
+            await MainActor.run {
+                self.profile.photoURL = url
             }
-
-            let url = try await storage.uploadProfilePhoto(imageData, userId: profile.id)
-            profile.photoURL = url
-            // Update profile with new photo URL
-            try await updateProfile()
+            
+            // Update profile in database
+            var updatedProfile = profile
+            updatedProfile.photoURL = url
+            
+            try await databaseManager.updateProfile(updatedProfile)
+            
+            // Force a reload of the profile
+            print("🔄 Forcing profile reload")
+            try? await forceSyncProfile()
         } catch {
+            print("❌ Profile photo update failed: \(error)")
+            print("- Error details: \(error.localizedDescription)")
             self.error = error
             throw error
         }
     }
+    
+    private func forceSyncProfile() async throws {
+        guard let userId = authService.currentUser?.uid else { return }
+        
+        do {
+            let freshProfile = try await databaseManager.fetchProfile(userId: userId)
+            
+            await MainActor.run {
+                print("🔄 Synced Profile:")
+                print("- New Photo URL: \(freshProfile.photoURL?.absoluteString ?? "nil")")
+                self.profile = freshProfile
+            }
+        } catch {
+            print("❌ Failed to sync profile: \(error)")
+            throw error
+        }
+    }
 
     func updateError(_ newError: Error?) {
         error = newError
@@ -70,4 +119,9 @@ final class EditProfileViewModel: ObservableObject {
             }
         }
     }
+
+    enum ProfileError: Error {
+        case notAuthenticated
+        case updateFailed
+    }
 }
diff --git a/ReelAI/ViewModels/Feed/FeedPaginator.swift b/ReelAI/ViewModels/Feed/FeedPaginator.swift
index f027ad1..ef28762 100644
--- a/ReelAI/ViewModels/Feed/FeedPaginator.swift
+++ b/ReelAI/ViewModels/Feed/FeedPaginator.swift
@@ -1,93 +1,137 @@
-// Pagination logic and batch loading
-// ~80 lines
-
+import Foundation
 import FirebaseDatabase
 import FirebaseStorage
+import os
 
-final class FeedPaginator {
+@MainActor
+class FeedPaginator {
+    private let logger = Logger(subsystem: Bundle.main.bundleIdentifier ?? "ReelAI", category: "FeedPaginator")
+    private let storage = Storage.storage()
+    private let database: DatabaseReference
+    private var lastFetchedTimestamp: Date?
     private let batchSize = 10
-    private var retryCount = 0
-    private let maxRetries = 3
-    private var lastLoadedKey: String?
-    private let storage = Storage.storage().reference()
-
-    func fetchNextBatch(from database: DatabaseReference) async throws -> [Video] {
-        var query = database.child("videos")
-            .queryOrdered(byChild: "timestamp")
-            .queryLimited(toFirst: UInt(batchSize))
-
-        if let lastKey = lastLoadedKey {
-            query = query.queryStarting(afterValue: nil, childKey: lastKey)
+    
+    init() {
+        self.database = Database.database().reference()
+    }
+    
+    func fetchNextBatch() async throws -> [Video] {
+        let videosRef = database.child("videos")
+        var query = videosRef.queryOrdered(byChild: "timestamp")
+        
+        if let lastTimestamp = lastFetchedTimestamp {
+            query = query.queryEnding(beforeValue: lastTimestamp.timeIntervalSince1970)
         }
-
-        return try await withCheckedThrowingContinuation { continuation in
-            query.observeSingleEvent(of: .value, with: { snapshot in
-                guard let videosDict = snapshot.value as? [String: [String: Any]] else {
-                    print("❌ No videos found or wrong data format. Raw value: \(String(describing: snapshot.value))")
-                    continuation.resume(throwing: NSError(
-                        domain: "FeedPaginator",
-                        code: 1,
-                        userInfo: [NSLocalizedDescriptionKey: "No videos found or invalid data format"]
-                    ))
-                    return
-                }
-
-                Task {
-                    do {
-                        let videos = try await self.processVideos(from: videosDict)
-                        if let lastChild = snapshot.children.allObjects.last as? DataSnapshot {
-                            self.lastLoadedKey = lastChild.key
-                        }
-                        continuation.resume(returning: videos)
-                    } catch {
-                        print("❌ Failed to process videos: \(error)")
-                        continuation.resume(throwing: error)
+        
+        query = query.queryLimited(toLast: UInt(batchSize))
+        let snapshot = try await query.getData()
+        
+        guard let value = snapshot.value as? [String: [String: Any]] else {
+            if snapshot.value == nil || snapshot.value is NSNull {
+                logger.debug("📭 No videos found in database")
+                return []
+            }
+            throw NSError(domain: "FeedPaginator", 
+                         code: 1, 
+                         userInfo: [NSLocalizedDescriptionKey: "Invalid data structure in Firebase"])
+        }
+        
+        logger.debug("📦 Processing \(value.count) video entries")
+        
+        let decoder = JSONDecoder()
+        decoder.dateDecodingStrategy = .secondsSince1970
+        
+        let processedVideos = try await withThrowingTaskGroup(of: ProcessedVideoResult.self) { group in
+            // Spawn tasks
+            for (key, dict) in value {
+                group.addTask { [weak self] in
+                    guard let self = self else { 
+                        return .skipped(key) 
                     }
+                    return try await self.processVideoEntry(key: key, dict: dict, decoder: decoder)
                 }
-            })
+            }
+            
+            // Collect results
+            var videos: [Video] = []
+            var skippedVideos: [String] = []
+            
+            for try await result in group {
+                switch result {
+                case .success(let video):
+                    videos.append(video)
+                case .skipped(let videoId):
+                    skippedVideos.append(videoId)
+                }
+            }
+            
+            if !skippedVideos.isEmpty {
+                logger.warning("⚠️ Skipped \(skippedVideos.count) videos: \(skippedVideos)")
+            }
+            
+            return videos.sorted { $0.createdAt > $1.createdAt }
         }
+        
+        if !processedVideos.isEmpty {
+            lastFetchedTimestamp = processedVideos.last?.createdAt
+        }
+        
+        logger.debug("📼 Fetched \(processedVideos.count) videos")
+        return processedVideos
     }
-
-    private func processVideos(from dict: [String: [String: Any]]) async throws -> [Video] {
-        var videos: [Video] = []
-
-        for (id, data) in dict {
+    
+    private enum ProcessedVideoResult {
+        case success(Video)
+        case skipped(String)
+    }
+    
+    private func processVideoEntry(key: String, dict: [String: Any], decoder: JSONDecoder) async throws -> ProcessedVideoResult {
+        var videoDict = dict
+        videoDict["id"] = key
+        
+        guard let videoName = videoDict["videoName"] as? String else {
+            logger.warning("❌ Missing videoName for video \(key)")
+            return .skipped(key)
+        }
+        
+        do {
+            let videoRef = storage.reference().child("videos/\(videoName)")
+            
+            // Check if video exists before attempting to download
             do {
-                if let videoName = data["videoName"] as? String,
-                   let timestamp = data["timestamp"] as? TimeInterval {
-
-                    let videoRef = storage.child("videos/\(videoName)")
-                    let videoURL = try await videoRef.downloadURL()
-
-                    let thumbnailRef = storage.child("thumbnails/\(videoName)")
-                    let thumbnailURL = try? await thumbnailRef.downloadURL()
-
-                    let video = Video(
-                        id: id,
-                        userId: data["userId"] as? String,
-                        videoURL: videoURL,
-                        thumbnailURL: thumbnailURL,
-                        createdAt: Date(timeIntervalSince1970: timestamp / 1000),
-                        caption: data["caption"] as? String ?? "",
-                        likes: data["likes"] as? Int ?? 0,
-                        comments: data["comments"] as? Int ?? 0
-                    )
-                    videos.append(video)
-                } else {
-                    print("❌ Missing videoName or timestamp for video \(id)")
-                }
+                _ = try await videoRef.getMetadata()
             } catch {
-                print("❌ Failed to process video \(id): \(error.localizedDescription)")
-                continue
+                logger.error("❌ Video \(key) does not exist: \(error.localizedDescription)")
+                return .skipped(key)
             }
+            
+            let url = try await videoRef.downloadURL()
+            videoDict["videoURL"] = url.absoluteString
+            
+            // Ensure timestamp exists and is a number
+            if let timestamp = videoDict["timestamp"] as? TimeInterval {
+                videoDict["timestamp"] = timestamp
+            } else {
+                videoDict["timestamp"] = Date().timeIntervalSince1970
+            }
+            
+            // Add default values for optional fields if missing
+            if videoDict["caption"] == nil { videoDict["caption"] = "" }
+            if videoDict["likes"] == nil { videoDict["likes"] = 0 }
+            if videoDict["comments"] == nil { videoDict["comments"] = 0 }
+            if videoDict["isDeleted"] == nil { videoDict["isDeleted"] = false }
+            if videoDict["privacyLevel"] == nil { videoDict["privacyLevel"] = "public" }
+            
+            let data = try JSONSerialization.data(withJSONObject: videoDict)
+            let video = try decoder.decode(Video.self, from: data)
+            return .success(video)
+        } catch {
+            logger.error("❌ Failed to process video \(key): \(error.localizedDescription)")
+            return .skipped(key)
         }
-
-        print("📊 Processed \(videos.count) valid videos out of \(dict.count) entries")
-        return videos.sorted(by: { $0.createdAt > $1.createdAt })
     }
-
-    func cleanup() {
-        retryCount = 0
-        lastLoadedKey = nil
+    
+    func reset() {
+        lastFetchedTimestamp = nil
     }
 }
diff --git a/ReelAI/ViewModels/Feed/VideoFeedViewModel.swift b/ReelAI/ViewModels/Feed/VideoFeedViewModel.swift
index dfe7e17..c6cba06 100644
--- a/ReelAI/ViewModels/Feed/VideoFeedViewModel.swift
+++ b/ReelAI/ViewModels/Feed/VideoFeedViewModel.swift
@@ -1,136 +1,159 @@
+import Foundation
 import FirebaseDatabase
-import AVFoundation
+import os
+import SwiftUI
+import Network
 
 @MainActor
-class VideoFeedViewModel: NSObject, ObservableObject {
-    struct FeedState {
-        var isLoading = false
-        var videos: [Video] = []
-        var error: String?
-        var loadingMessage: String?
+class VideoFeedViewModel: ObservableObject {
+    @Published private(set) var currentVideo: Video?
+    @Published private(set) var previousVideo: Video?
+    @Published private(set) var nextVideo: Video?
+    @Published private(set) var isLoading = false
+    @Published private(set) var error: String?
+    @Published private(set) var networkStatus: NetworkMonitor.NetworkStatus = .unknown
+    @Published var transitionProgress: Double = 0
+
+    private var videos: [Video] = []
+    private var currentIndex = 0
+    private let paginator: FeedPaginator
+    private let logger = Logger(subsystem: Bundle.main.bundleIdentifier ?? "ReelAI", category: "VideoFeedViewModel")
+    private var isPreloadingMore = false
+    private let networkMonitor = NetworkMonitor.shared
+    private var retryCount = 0
+    private let maxRetries = 3
+
+    init(paginator: FeedPaginator? = nil) {
+        self.paginator = paginator ?? FeedPaginator()
+        setupNetworkMonitoring()
     }
 
-    @Published private(set) var state = FeedState()
-    @Published var currentlyPlayingId: String?
-
-    var isLoading: Bool { state.isLoading }
-    var videos: [Video] { state.videos }
-    var error: String? { state.error }
-    var loadingMessage: String? { state.loadingMessage }
-
-    private let paginator: FeedPaginator
-    private let database: DatabaseReference
-    private var preloadedVideos: Set<String> = []
+    private func setupNetworkMonitoring() {
+        networkMonitor.startMonitoring { [weak self] status in
+            guard let self = self else { return }
 
-    override init() {
-        self.database = Database.database().reference()
-        self.paginator = FeedPaginator()
-        super.init()
-    }
+            Task { @MainActor in
+                // Update status and check if we need to load videos
+                self.networkStatus = status
 
-    init(database: DatabaseReference = Database.database().reference(),
-         paginator: FeedPaginator = .init()) {
-        self.database = database
-        self.paginator = paginator
-        super.init()
+                // Only start loading if we have no videos
+                let shouldLoad = status == .satisfied && self.videos.isEmpty
+                if shouldLoad {
+                    await self.loadVideos()
+                }
+            }
+        }
     }
 
-    func loadVideos() {
-        Task {
-            await loadVideosWithRetry()
+    func loadVideos() async {
+        guard networkStatus == .satisfied else {
+            error = "No network connection"
+            return
         }
-    }
 
-    private func loadVideosWithRetry(delay: TimeInterval = 1.0) async {
-        state.isLoading = true
-        state.loadingMessage = "Loading videos..."
-        print("📡 Loading videos...")
+        isLoading = true
+        error = nil
 
         do {
-            print("📡 Fetching next batch...")
-            let videos = try await paginator.fetchNextBatch(from: database)
-            print("📡 Got \(videos.count) videos")
-            
-            guard !videos.isEmpty else {
-                state.error = "No videos available"
-                state.isLoading = false
-                state.loadingMessage = nil
-                return
-            }
-            
-            // Shuffle once and store the order
-            if state.videos.isEmpty {
-                state.videos = videos.shuffled()
-                // Set initial playing video
-                if currentlyPlayingId == nil {
-                    currentlyPlayingId = state.videos.first?.id
-                    print("📱 Set initial playing video: \(currentlyPlayingId ?? "none")")
-                }
+            videos = try await fetchVideosWithRetry()
+            if !videos.isEmpty {
+                currentIndex = 0
+                updateVideoViews()
+                preloadNextBatchIfNeeded()
             } else {
-                state.videos = videos
+                error = "No videos found"
             }
-            
-            state.isLoading = false
-            state.loadingMessage = nil
-            print("📡 Updated state with videos: \(videos.count) videos available")
-            
         } catch {
-            print("❌ Load error: \(error)")
-            await handleLoadError(error, delay: delay)
+            handleLoadError(error)
         }
-    }
 
-    private func handleLoadError(_ error: Error, delay: TimeInterval) async {
-        print("❌ Failed to load videos: \(error.localizedDescription)")
-        state.error = error.localizedDescription
-        state.isLoading = false
-        print("❌ Updated state with error")
+        isLoading = false
     }
 
-    func preloadVideo(_ video: Video) async {
-        guard !preloadedVideos.contains(video.id) else { return }
-        preloadedVideos.insert(video.id)
-        print("🎥 Preloading video: \(video.id)")
-    }
-    
-    func cancelPreload(_ videoId: String) {
-        preloadedVideos.remove(videoId)
-        print("🎥 Cancelled preload for: \(videoId)")
-    }
+    private func fetchVideosWithRetry() async throws -> [Video] {
+        var lastError: Error?
 
-    func cleanup() {
-        preloadedVideos.removeAll()
-        paginator.cleanup()
+        for attempt in 0..<maxRetries {
+            do {
+                return try await paginator.fetchNextBatch()
+            } catch {
+                lastError = error
+
+                // Only retry for network-related errors
+                guard error.isRetryableNetworkError else {
+                    throw error
+                }
+
+                // Exponential backoff
+                try await Task.sleep(nanoseconds: UInt64(pow(2.0, Double(attempt)) * 1_000_000_000))
+            }
+        }
+
+        throw lastError ?? NSError(domain: "VideoFeedError", code: -1, userInfo: [NSLocalizedDescriptionKey: "Failed to fetch videos"])
     }
 
-    func setLoading(_ isLoading: Bool) {
-        state.isLoading = isLoading
+    private func handleLoadError(_ error: Error) {
+        let networkError = error as NSError
+
+        NetworkErrorHandler.handle(
+            error,
+            retryAction: { [weak self] in
+                // Retry action
+                Task { await self?.loadVideos() }
+            },
+            fallbackAction: { [weak self] in
+                // Fallback action
+                self?.error = networkError.localizedDescription
+                self?.logger.error("❌ Failed to load videos: \(networkError.localizedDescription)")
+            }
+        )
     }
 
-    func setError(_ message: String?) {
-        state.error = message
+    func moveToNext() {
+        guard currentIndex < videos.count - 1 else { return }
+        currentIndex += 1
+        updateVideoViews()
+        preloadNextBatchIfNeeded()
     }
 
-    func reset() {
-        state = FeedState()
-        preloadedVideos.removeAll()
-        loadVideos()
+    func moveToPrevious() {
+        guard currentIndex > 0 else { return }
+        currentIndex -= 1
+        updateVideoViews()
     }
 
-    func handleBackground() async {
-        print("📱 App entered background")
-        // Pause current video if needed
+    private func updateVideoViews() {
+        currentVideo = videos[currentIndex]
+        previousVideo = videos[safe: currentIndex - 1]
+        nextVideo = videos[safe: currentIndex + 1]
     }
 
-    func handleForeground() async {
-        print("📱 App entered foreground")
-        // Resume current video if needed
+    private func preloadNextBatchIfNeeded() {
+        guard !isPreloadingMore,
+              currentIndex >= videos.count - 3,
+              !videos.isEmpty,
+              networkStatus == .satisfied else { return }
+
+        Task {
+            isPreloadingMore = true
+            do {
+                let newVideos = try await fetchVideosWithRetry()
+                if !newVideos.isEmpty {
+                    videos.append(contentsOf: newVideos)
+                    updateVideoViews()
+                }
+            } catch {
+                logger.error("❌ Failed to preload next batch: \(error.localizedDescription)")
+            }
+            isPreloadingMore = false
+        }
     }
-    
-    // For previews only
-    #if DEBUG
-    func setVideos(_ videos: [Video]) {
-        state.videos = videos
+
+    deinit {
+        // Avoid capturing self in the deinit Task
+        let monitor = networkMonitor
+        Task {
+            await monitor.stopMonitoring()
+        }
     }
-    #endif
 }
diff --git a/ReelAI/ViewModels/ProfileViewModel.swift b/ReelAI/ViewModels/ProfileViewModel.swift
index 3dfed64..2d2672e 100644
--- a/ReelAI/ViewModels/ProfileViewModel.swift
+++ b/ReelAI/ViewModels/ProfileViewModel.swift
@@ -5,34 +5,38 @@ import FirebaseDatabase
 import FirebaseStorage
 import os
 
+/// Manages profile data and video content for a user
 @MainActor
 class ProfileViewModel: ObservableObject {
+    // MARK: - Published Properties
     @Published private(set) var videos: [Video] = []
     @Published private(set) var error: Error?
     @Published private(set) var isLoading = false
     @Published private(set) var profile: UserProfile
+
+    // MARK: - Private Properties
     private var hasLoadedVideos = false
     private var cachedVideos: [Video]?
     private let logger = Logger(subsystem: Bundle.main.bundleIdentifier ?? "ReelAI", category: "ProfileViewModel")
+    private let videoLoader: ProfileVideoLoader
+    private let profileManager: ProfileManager
 
+    // MARK: - Dependencies
     let authService: AuthServiceProtocol
-    private let db = Database.database().reference()
-    private let storage = Storage.storage().reference()
     let storageManager: StorageManager
     let databaseManager: DatabaseManager
 
-    private var thumbnailCache: [TimeInterval: StorageReference]?
-
+    // MARK: - Initialization
     init(
         authService: AuthServiceProtocol,
-        storage: StorageManager = FirebaseStorageManager(),
-        database: DatabaseManager = FirebaseDatabaseManager()
+        storage: StorageManager,
+        database: DatabaseManager
     ) {
         self.authService = authService
         self.storageManager = storage
         self.databaseManager = database
 
-        // Initialize with a temporary profile that will be replaced
+        // Initialize with temporary profile
         if let userId = authService.currentUser?.uid {
             self.profile = UserProfile(
                 id: userId,
@@ -42,299 +46,157 @@ class ProfileViewModel: ObservableObject {
                 socialLinks: []
             )
         } else {
-            self.profile = UserProfile.mock // Temporary fallback
+            self.profile = UserProfile.mock
         }
 
-        // Set up notification observer for cache clearing
+        // Initialize managers
+        self.videoLoader = ProfileVideoLoader(database: database, logger: logger)
+        self.profileManager = ProfileManager(database: database, auth: authService)
+
+        setupObservers()
+        Task { await loadProfile() }
+    }
+
+    private func setupObservers() {
         NotificationCenter.default.addObserver(
             self,
-            selector: #selector(handleCacheCleared),
-            name: .videoCacheCleared,
+            selector: #selector(clearCache),
+            name: UIApplication.didReceiveMemoryWarningNotification,
             object: nil
         )
-
-        // Load the real profile
-        Task {
-            await loadProfile()
-        }
     }
 
-    @objc private func handleCacheCleared() {
+    @objc private func clearCache() {
         Task {
-            // Force reload videos from Firebase when cache is cleared
             cachedVideos = nil
             await loadVideos()
         }
     }
 
+    // MARK: - Profile Management
     func loadProfile() async {
-        guard let userId = authService.currentUser?.uid else { return }
-
         do {
-            let loadedProfile = try await databaseManager.fetchProfile(userId: userId)
-            await MainActor.run {
-                self.profile = loadedProfile
-            }
+            let loadedProfile = try await profileManager.loadProfile()
+            await updateProfile(with: loadedProfile)
         } catch {
-            print("❌ Failed to load profile: \(error)")
-            // Create new profile if none exists
-            let newProfile = UserProfile(
-                id: userId,
-                displayName: authService.currentUser?.displayName ?? "New User",
-                bio: "",
-                photoURL: authService.currentUser?.photoURL,
-                socialLinks: [] // Explicitly set empty array
-            )
+            logger.error("Failed to load profile: \(error.localizedDescription)")
+            await createFallbackProfile()
+        }
+    }
 
-            do {
-                try await databaseManager.updateProfile(newProfile)
-                await MainActor.run {
-                    self.profile = newProfile
-                }
-            } catch {
-                print("❌ Failed to create new profile: \(error)")
-            }
+    private func updateProfile(with loadedProfile: UserProfile) async {
+        await MainActor.run {
+            profile = loadedProfile
+            objectWillChange.send()
+            NotificationCenter.default.post(
+                name: Notification.Name("ProfilePhotoUpdated"),
+                object: profile.photoURL
+            )
         }
     }
 
-    static func createDefault() async -> ProfileViewModel {
-        return ProfileViewModel(
-            authService: FirebaseAuthService()
+    private func createFallbackProfile() async {
+        guard let userId = authService.currentUser?.uid else { return }
+
+        let newProfile = UserProfile(
+            id: userId,
+            displayName: authService.currentUser?.displayName ?? "New User",
+            bio: "",
+            photoURL: authService.currentUser?.photoURL,
+            socialLinks: []
         )
+
+        do {
+            try await databaseManager.updateProfile(newProfile)
+            await updateProfile(with: newProfile)
+        } catch {
+            logger.error("Failed to create fallback profile: \(error.localizedDescription)")
+        }
     }
 
+    // MARK: - Video Management
     func loadVideos() async {
         guard !isLoading else { return }
         guard let userId = authService.currentUser?.uid else { return }
 
         isLoading = true
-        logger.info("🎬 Starting to load videos")
 
         do {
-            // Clear cached data
-            cachedVideos = nil
-
-            // Disable persistence for this query
-            db.child("videos").keepSynced(false)
-
-            let snapshot = try await db.child("videos")
-                .queryOrdered(byChild: "timestamp")
-                .queryLimited(toLast: 50)
-                .getData()
-
-            print("📄 Got \(snapshot.childrenCount) videos from database")
-
-            // Log raw data for debugging
-            if let rawData = snapshot.value as? [String: [String: Any]] {
-                for (id, data) in rawData {
-                    logger.debug("🔍 Raw video data - ID: \(id), isDeleted: \(data["isDeleted"] as? Bool ?? false)")
-                }
-            }
+            let loadedVideos = try await videoLoader.loadVideos(for: userId)
+            await updateVideos(with: loadedVideos)
+        } catch {
+            await handleVideoLoadError(error)
+        }
+    }
 
-            let loadedVideos = try await loadVideosFromSnapshot(snapshot, userId: userId)
+    private func updateVideos(with videos: [Video]) async {
+        await MainActor.run {
+            self.videos = videos.sorted { $0.createdAt > $1.createdAt }
+            self.cachedVideos = self.videos
+            isLoading = false
+            hasLoadedVideos = true
+        }
+    }
 
-            await MainActor.run {
-                self.videos = loadedVideos.sorted { $0.createdAt > $1.createdAt }
-                self.cachedVideos = loadedVideos.sorted { $0.createdAt > $1.createdAt }
-                logger.info("📄 Got \(loadedVideos.count) videos from database")
-                logger.debug("""
-📼 Loaded videos:
-\(self.videos.map { video in
-    "id: \(video.id.prefix(6)), privacy: \(video.privacyLevel), deleted: \(video.isDeleted), caption: \(video.caption.prefix(20))..."
-}.joined(separator: "\n"))
-""")
-                isLoading = false
-                hasLoadedVideos = true
-            }
-        } catch {
-            await MainActor.run {
-                self.error = error
-                logger.error("❌ Failed to load videos: \(error.localizedDescription)")
-                isLoading = false
-            }
+    private func handleVideoLoadError(_ error: Error) async {
+        await MainActor.run {
+            self.error = error
+            logger.error("Failed to load videos: \(error.localizedDescription)")
+            isLoading = false
         }
     }
 
     func forceRefreshVideos() async {
-        logger.debug("🔄 Force refreshing videos")
+        logger.debug("Force refreshing videos")
         hasLoadedVideos = false
         cachedVideos = nil
         await loadVideos()
     }
 
-    private func loadVideosFromSnapshot(_ snapshot: DataSnapshot, userId: String) async throws -> [Video] {
-        var loadedVideos: [Video] = []
-
-        for child in snapshot.children {
-            guard let snapshot = child as? DataSnapshot,
-                  let data = snapshot.value as? [String: Any],
-                  let videoName = data["videoName"] as? String,
-                  let timestamp = data["timestamp"] as? TimeInterval else {
-                continue
-            }
-
-            do {
-                let videoRef = storage.child("videos/\(videoName)")
-                let videoURL = try await videoRef.downloadURL()
-                let videoMetadata = try await videoRef.getMetadata()
-
-                // Try to get thumbnail but don't fail if not found
-                let thumbnailURL: URL? = try? await getThumbnailURL(
-                    for: videoName,
-                    timestamp: videoMetadata.timeCreated?.timeIntervalSince1970 ?? timestamp
-                )
-
-                let video = Video(
-                    id: snapshot.key,
-                    userId: data["userId"] as? String ?? userId,
-                    videoURL: videoURL,
-                    thumbnailURL: thumbnailURL,
-                    createdAt: Date(timeIntervalSince1970: TimeInterval(timestamp) / 1000.0),
-                    caption: data["caption"] as? String ?? "",
-                    likes: data["likes"] as? Int ?? 0,
-                    comments: data["comments"] as? Int ?? 0,
-                    isDeleted: data["isDeleted"] as? Bool ?? false,
-                    privacyLevel: Video.PrivacyLevel(rawValue: data["privacyLevel"] as? String ?? "public") ?? .public
-                )
-                loadedVideos.append(video)
-
-                logger.debug("""
-📼 Video loaded:
-ID: \(snapshot.key)
-Deleted: \(data["isDeleted"] as? Bool ?? false)
-Privacy: \(data["privacyLevel"] as? String ?? "public")
-Caption: \(data["caption"] as? String ?? "")
-""")
-            } catch {
-                print("❌ Failed to load video: \(videoName)")
-                continue
-            }
-        }
-
-        return loadedVideos
-    }
-
-    func setVideos(_ newVideos: [Video]) {
-        videos = newVideos
+    // MARK: - Convenience Initializer
+    convenience init(authService: AuthServiceProtocol) {
+        self.init(
+            authService: authService,
+            storage: FirebaseStorageManager(),
+            database: FirebaseDatabaseManager.shared
+        )
     }
+}
 
-    func setLoading(_ loading: Bool) {
-        isLoading = loading
-    }
+// MARK: - Profile Manager
+private actor ProfileManager {
+    private let database: DatabaseManager
+    private let auth: AuthServiceProtocol
 
-    func setError(_ newError: Error?) {
-        error = newError
+    init(database: DatabaseManager, auth: AuthServiceProtocol) {
+        self.database = database
+        self.auth = auth
     }
 
-    private func loadThumbnailCache() async throws {
-        guard thumbnailCache == nil else { return }
-
-        let thumbnails = try await storage.child("thumbnails").listAll()
-        var cache: [TimeInterval: StorageReference] = [:]
-
-        for item in thumbnails.items {
-            if let metadata = try? await item.getMetadata(),
-               let created = metadata.timeCreated {
-                cache[created.timeIntervalSince1970] = item
-            }
+    func loadProfile() async throws -> UserProfile {
+        guard let userId = auth.currentUser?.uid else {
+            throw NSError(domain: "ProfileError", code: -1, userInfo: [NSLocalizedDescriptionKey: "No authenticated user"])
         }
-
-        thumbnailCache = cache
+        return try await database.fetchProfile(userId: userId)
     }
+}
 
-    private func getThumbnailURL(for videoName: String, timestamp: TimeInterval) async throws -> URL {
-        let baseVideoName = videoName.replacingOccurrences(of: ".mp4", with: "")
-        let newPatternRef = storage.child("thumbnails/\(baseVideoName).jpg")
-
-        do {
-            return try await newPatternRef.downloadURL()
-        } catch let downloadError {
-            try await loadThumbnailCache()
-            guard let cache = thumbnailCache else { throw downloadError }
-
-            for (thumbTimestamp, thumbnailRef) in cache where abs(thumbTimestamp - timestamp) < 2.0 {
-                return try await thumbnailRef.downloadURL()
-            }
+// MARK: - Video Loader
+private actor ProfileVideoLoader {
+    private let database: DatabaseManager
+    private let logger: Logger
 
-            throw downloadError
-        }
+    init(database: DatabaseManager, logger: Logger) {
+        self.database = database
+        self.logger = logger
     }
 
-    private func processVideos(from dict: [String: [String: Any]]) async throws -> [Video] {
-        var videos: [Video] = []
-
-        for (id, data) in dict {
-            if let userId = data["userId"] as? String,
-               let videoURLString = data["videoURL"] as? String,
-               let videoURL = URL(string: videoURLString),
-               let thumbnailURLString = data["thumbnailURL"] as? String,
-               let thumbnailURL = URL(string: thumbnailURLString),
-               let timestamp = data["timestamp"] as? TimeInterval {
-
-                let video = Video(
-                    id: id,
-                    userId: userId,
-                    videoURL: videoURL,
-                    thumbnailURL: thumbnailURL,
-                    createdAt: Date(timeIntervalSince1970: timestamp),
-                    caption: data["caption"] as? String ?? "",
-                    likes: data["likes"] as? Int ?? 0,
-                    comments: data["comments"] as? Int ?? 0
-                )
-                videos.append(video)
-            }
-        }
+    func loadVideos(for userId: String) async throws -> [Video] {
+        logger.info("Starting to load videos")
 
-        return videos.sorted(by: { $0.createdAt > $1.createdAt })
-    }
-
-    func softDelete(_ video: Video) async {
-        logger.debug("🔴 ProfileViewModel: Starting soft delete for video \(video.id)")
-        isLoading = true
-        do {
-            // Optimistically update UI
-            await MainActor.run {
-                if let index = videos.firstIndex(where: { $0.id == video.id }) {
-                    var updatedVideo = video
-                    updatedVideo.isDeleted = true
-                    videos[index] = updatedVideo
-                }
-            }
-            
-            // Then update database
-            try await databaseManager.softDeleteVideo(video.id)
-            // Still refresh to ensure consistency
-            await forceRefreshVideos()
-        } catch {
-            // Revert on error
-            await forceRefreshVideos()
-            logger.error("❌ ProfileViewModel: Failed to delete: \(error.localizedDescription)")
-            self.error = error
-        }
-        isLoading = false
-    }
+        let videos = try await database.fetchVideos(for: userId, limit: 50)
+        logger.info("Loaded \(videos.count) videos")
 
-    func restore(_ video: Video) async {
-        isLoading = true
-        do {
-            // Optimistically update UI
-            await MainActor.run {
-                if let index = videos.firstIndex(where: { $0.id == video.id }) {
-                    var updatedVideo = video
-                    updatedVideo.isDeleted = false
-                    videos[index] = updatedVideo
-                }
-            }
-            
-            // Then update database
-            try await databaseManager.restoreVideo(video.id)
-            // Still refresh to ensure consistency
-            await forceRefreshVideos()
-        } catch {
-            // Revert on error
-            await forceRefreshVideos()
-            self.error = error
-        }
-        isLoading = false
+        return videos
     }
 }
diff --git a/ReelAI/ViewModels/Upload/UploadManager.swift b/ReelAI/ViewModels/Upload/UploadManager.swift
index 3cc00f1..23ef6da 100644
--- a/ReelAI/ViewModels/Upload/UploadManager.swift
+++ b/ReelAI/ViewModels/Upload/UploadManager.swift
@@ -8,6 +8,7 @@ extension Notification.Name {
     static let uploadProgressUpdated = Notification.Name("uploadProgressUpdated")
 }
 
+@MainActor
 final class UploadManager {
     private let storage: StorageReference
     private let database: DatabaseReference
@@ -74,6 +75,54 @@ final class UploadManager {
         print("✅ Metadata saved successfully")
     }
 
+    func uploadMultipleVideos(_ urls: [URL], metadatas: [VideoMetadata]) async throws -> [VideoUploadResult] {
+        print("🚀 Starting multiple video uploads: \(urls.count) videos")
+
+        var uploadResults: [VideoUploadResult] = []
+
+        // Use structured concurrency to upload videos in parallel
+        try await withThrowingTaskGroup(of: VideoUploadResult.self) { group in
+            for (index, url) in urls.enumerated() {
+                group.addTask {
+                    let metadata = metadatas[index]
+                    return try await self.uploadVideo(url, metadata: metadata)
+                }
+            }
+
+            // Collect results as they complete
+            for try await result in group {
+                uploadResults.append(result)
+
+                // Notify progress
+                NotificationCenter.default.post(
+                    name: .uploadProgressUpdated,
+                    object: nil,
+                    userInfo: ["progress": Double(uploadResults.count) / Double(urls.count)]
+                )
+            }
+        }
+
+        print("✅ Completed multiple video uploads: \(uploadResults.count) videos")
+        return uploadResults
+    }
+
+    func saveMultipleMetadata(_ metadatas: [VideoMetadata]) async throws {
+        print("🔄 Saving metadata for multiple videos: \(metadatas.count)")
+
+        try await withThrowingTaskGroup(of: Void.self) { group in
+            for metadata in metadatas {
+                group.addTask {
+                    try await self.saveMetadata(metadata)
+                }
+            }
+
+            // Wait for all metadata saves to complete
+            try await group.waitForAll()
+        }
+
+        print("✅ Saved metadata for all videos")
+    }
+
     func cancelUpload() {
         currentUploadTask?.cancel()
         currentUploadTask = nil
diff --git a/ReelAI/ViewModels/Upload/VideoProcessor.swift b/ReelAI/ViewModels/Upload/VideoProcessor.swift
index 9fc25c2..a87df0f 100644
--- a/ReelAI/ViewModels/Upload/VideoProcessor.swift
+++ b/ReelAI/ViewModels/Upload/VideoProcessor.swift
@@ -4,6 +4,7 @@
 import AVFoundation
 import UIKit
 
+@MainActor
 final class VideoProcessor {
     enum Quality {
         case high    // 1080p, 8Mbps
diff --git a/ReelAI/ViewModels/Upload/VideoUploadViewModel.swift b/ReelAI/ViewModels/Upload/VideoUploadViewModel.swift
index 5e61f05..e1f0b52 100644
--- a/ReelAI/ViewModels/Upload/VideoUploadViewModel.swift
+++ b/ReelAI/ViewModels/Upload/VideoUploadViewModel.swift
@@ -1,180 +1,195 @@
-// Core view model with main upload flow and state management
-// ~100 lines
-
 import SwiftUI
 import FirebaseAuth
 import FirebaseStorage
+import FirebaseDatabase
+import AVFoundation
+import CoreMedia
+import Network
+import UIKit
+import Foundation
 
 @MainActor
-final class VideoUploadViewModel: ObservableObject {
-    @Published private(set) var uploadProgress: Double = 0
-    @Published private(set) var isUploading = false
-    @Published private(set) var errorMessage: String?
+final class VideoUploadViewModel: ObservableObject, VideoUploadViewModelProtocol {
+    // MARK: - Published Properties
+    @Published var uploadProgress: Double = 0
+    @Published var isUploading = false
+    @Published var errorMessage: String?
     @Published var selectedVideoURL: URL?
     @Published var thumbnailImage: UIImage?
     @Published var caption: String = ""
-    @Published private(set) var uploadComplete = false
+    @Published var uploadComplete = false
     @Published var lastUploadedVideoURL: URL?
-    @Published var selectedQuality: VideoProcessor.Quality = .medium
+    @Published var selectedQuality: VideoQuality = .medium
     @Published var shouldNavigateToProfile = false
+    @Published var selectedVideoURLs: [URL] = []
+    @Published var uploadedVideoURLs: [URL] = []
+    @Published var uploadStatuses: [URL: UploadStatus] = [:]
+    @Published var thumbnails: [URL: UIImage] = [:]
+    @Published var networkStatus: NetworkMonitor.NetworkStatus = .unknown
+
+    // MARK: - Dependencies
+    private let networkMonitor = NetworkMonitor.shared
+    private let videoProcessor = VideoProcessor()
+    private let storageManager: StorageManager
+    private let databaseManager: FirebaseDatabaseManager
+
+    // MARK: - Initialization
+    init(storageManager: StorageManager, databaseManager: FirebaseDatabaseManager) {
+        self.storageManager = storageManager
+        self.databaseManager = databaseManager
+        setupNetworkMonitoring()
+    }
 
-    private let processor: VideoProcessor
-    private let uploadManager: UploadManager
-    private let progressTracker: UploadProgress
-
-    init(processor: VideoProcessor = .init(),
-         uploadManager: UploadManager = .init(),
-         progressTracker: UploadProgress = .init()) {
-        self.processor = processor
-        self.uploadManager = uploadManager
-        self.progressTracker = progressTracker
-        
-        // Observe upload progress
-        NotificationCenter.default.addObserver(
-            self,
-            selector: #selector(handleProgressUpdate),
-            name: .uploadProgressUpdated,
-            object: nil
-        )
+    // Convenience initializer with default dependencies
+    convenience init() {
+        self.init(storageManager: FirebaseStorageManager(), databaseManager: FirebaseDatabaseManager.shared)
     }
 
-    @objc private func handleProgressUpdate(_ notification: Notification) {
-        if let progress = notification.userInfo?["progress"] as? Double {
-            DispatchQueue.main.async {
-                self.uploadProgress = progress
-            }
+    private func setupNetworkMonitoring() {
+        networkMonitor.startMonitoring { [weak self] status in
+            guard let self = self else { return }
+            self.networkStatus = status
         }
     }
 
-    func uploadVideo() {
-        print("📱 Starting upload process")
-        guard let videoURL = selectedVideoURL else {
-            print("❌ No video URL selected")
-            errorMessage = "No video selected"
-            return
+    // MARK: - VideoUploadViewModelProtocol Implementation
+    public func setSelectedVideos(urls: [URL]) {
+        selectedVideoURLs = urls
+        uploadStatuses = Dictionary(uniqueKeysWithValues: urls.map { ($0, .pending) })
+
+        Task {
+            await self.generateThumbnails(for: urls)
         }
+    }
+
+    public func setError(_ error: PublicUploadError) {
+        errorMessage = error.localizedDescription
+    }
 
-        guard NetworkMonitor.shared.isConnected else {
-            print("❌ No network connection")
-            errorMessage = "No internet connection. Please try again."
+    public func uploadVideos() {
+        guard !selectedVideoURLs.isEmpty else {
+            setError(.videoProcessingFailed(reason: "No videos selected"))
             return
         }
 
-        isUploading = true
-        errorMessage = nil
+        guard networkMonitor.isConnected else {
+            setError(.networkUnavailable)
+            return
+        }
 
         Task {
+            self.isUploading = true
+
             do {
-                try await processAndUploadVideo(from: videoURL)
+                try await self.uploadSelectedVideos()
+                await MainActor.run {
+                    self.uploadComplete = true
+                    self.isUploading = false
+                }
             } catch {
-                await handleUploadError(error)
+                await MainActor.run {
+                    self.setError(.videoProcessingFailed(reason: error.localizedDescription))
+                    self.isUploading = false
+                }
             }
         }
     }
 
-    private func processAndUploadVideo(from videoURL: URL) async throws {
-        // 1. Compress video
-        print("📱 Starting video compression")
-        let compressedVideoURL = try await processor.compressVideo(at: videoURL, quality: selectedQuality)
-        defer { try? FileManager.default.removeItem(at: compressedVideoURL) }
-
-        // 2. Generate thumbnail and metadata
-        let baseVideoName = UUID().uuidString
-        let videoName = baseVideoName + ".mp4"
-        let thumbnailName = baseVideoName + ".jpg"
-        print("📱 Starting video upload: \(videoName)")
-
-        guard let userId = Auth.auth().currentUser?.uid else {
-            throw NSError(domain: "UploadError", code: -1, userInfo: [NSLocalizedDescriptionKey: "User not authenticated"])
-        }
+    // MARK: - Private Methods
+    private func generateThumbnails(for urls: [URL]) async {
+        await withTaskGroup(of: (URL, UIImage?).self) { group in
+            for url in urls {
+                group.addTask {
+                    return (url, await self.generateThumbnail(for: url))
+                }
+            }
 
-        // Generate and upload thumbnail
-        guard let thumbnail = thumbnailImage,
-              let thumbnailData = thumbnail.jpegData(compressionQuality: 0.8) else {
-            throw NSError(domain: "UploadError", code: -2, userInfo: [NSLocalizedDescriptionKey: "Could not prepare thumbnail"])
+            for await (url, thumbnail) in group {
+                if let thumbnail = thumbnail {
+                    self.thumbnails[url] = thumbnail
+                }
+            }
         }
-
-        let thumbnailRef = Storage.storage().reference().child("thumbnails/\(thumbnailName)")
-        let thumbnailMetadata = StorageMetadata()
-        thumbnailMetadata.contentType = "image/jpeg"
-        _ = try await thumbnailRef.putDataAsync(thumbnailData, metadata: thumbnailMetadata)
-        let thumbnailURL = try await thumbnailRef.downloadURL()
-
-        let metadata = VideoMetadata(
-            userId: userId,
-            videoName: videoName,
-            caption: caption,
-            timestamp: Date(),
-            thumbnailURL: thumbnailURL.absoluteString
-        )
-
-        // 3. Upload video
-        let result = try await uploadManager.uploadVideo(compressedVideoURL, metadata: metadata)
-        lastUploadedVideoURL = result.videoURL
-
-        // 4. Save metadata
-        try await uploadManager.saveMetadata(metadata)
-
-        // 5. Update UI
-        updateUIAfterSuccess()
     }
 
-    private func handleUploadError(_ error: Error) async {
-        print("❌ Upload error: \(error.localizedDescription)")
-        let nsError = error as NSError
-        if nsError.domain == StorageErrorDomain &&
-           nsError.code == StorageErrorCode.cancelled.rawValue {
-            errorMessage = "Upload canceled"
-        } else {
-            errorMessage = "Upload failed: \(error.localizedDescription)"
-        }
-        isUploading = false
-    }
+    private func uploadSelectedVideos() async throws {
+        for url in selectedVideoURLs {
+            do {
+                let processedURL = try await videoProcessor.compressVideo(at: url, quality: mapQuality(selectedQuality))
+                let videoName = "\(UUID().uuidString).mp4"
+
+                uploadStatuses[url] = .uploading(progress: 0)
+                let downloadURL = try await storageManager.uploadVideo(processedURL, name: videoName)
+
+                var thumbnailURL: URL?
+                if let thumbnailImage = thumbnails[url],
+                   let thumbnailData = thumbnailImage.jpegData(compressionQuality: 0.8) {
+                    thumbnailURL = try await storageManager.uploadThumbnail(thumbnailData, for: videoName)
+                }
+
+                let video = Video(
+                    id: videoName,
+                    userId: Auth.auth().currentUser?.uid,
+                    videoURL: downloadURL,
+                    thumbnailURL: thumbnailURL,
+                    createdAt: Date(),
+                    caption: caption,
+                    likes: 0,
+                    comments: 0,
+                    isDeleted: false,
+                    privacyLevel: .public
+                )
+
+                try await databaseManager.updateVideo(video)
+                uploadStatuses[url] = .completed(downloadURL)
+                uploadedVideoURLs.append(downloadURL)
 
-    private func updateUIAfterSuccess() {
-        uploadComplete = true
-        isUploading = false
-        selectedVideoURL = nil
-        thumbnailImage = nil
-        caption = ""
-        errorMessage = "✅ Upload complete!"
-        shouldNavigateToProfile = true
+            } catch {
+                uploadStatuses[url] = .failed(error)
+                throw error
+            }
+        }
     }
 
-    func setError(_ message: String) {
-        errorMessage = message
+    private func mapQuality(_ quality: VideoQuality) -> VideoProcessor.Quality {
+        switch quality {
+        case .high:
+            return .high
+        case .medium:
+            return .medium
+        case .low:
+            return .low
+        }
     }
 
-    func setSelectedVideo(url: URL) {
-        print("📱 ViewModel: Setting selected video URL: \(url.path)")
-        selectedVideoURL = url
-        Task {
-            do {
-                print("📱 ViewModel: Generating thumbnail...")
-                thumbnailImage = try await processor.generateThumbnail(from: url)
-                print("📱 ViewModel: Thumbnail generated successfully")
-            } catch {
-                print("❌ ViewModel: Thumbnail generation failed: \(error.localizedDescription)")
-                setError("Could not generate thumbnail: \(error.localizedDescription)")
+    private func generateThumbnail(for videoURL: URL) async -> UIImage? {
+        let asset = AVURLAsset(url: videoURL)
+        let generator = AVAssetImageGenerator(asset: asset)
+        generator.appliesPreferredTrackTransform = true
+
+        return await withCheckedContinuation { continuation in
+            generator.generateCGImageAsynchronously(
+                for: CMTime(seconds: 1, preferredTimescale: 60)
+            ) { cgImage, _, error in
+                if let error = error {
+                    print("❌ Could not generate thumbnail for video: \(error.localizedDescription)")
+                    continuation.resume(returning: nil)
+                    return
+                }
+
+                if let cgImage = cgImage {
+                    continuation.resume(returning: UIImage(cgImage: cgImage))
+                } else {
+                    continuation.resume(returning: nil)
+                }
             }
         }
     }
 
     func cancelUpload() {
-        print("📱 Cancel button pressed")
-        uploadManager.cancelUpload()
-        isUploading = false
-        uploadProgress = 0
-        errorMessage = "Upload canceled"
-    }
-
-    func reset() {
-        selectedVideoURL = nil
-        thumbnailImage = nil
-        caption = ""
-        uploadComplete = false
-        uploadProgress = 0
-        errorMessage = nil
+        // Cancel any ongoing upload process if applicable
+        // For now, we simply set isUploading to false as a placeholder
         isUploading = false
+        // If there are any async tasks or network requests, cancel them here
     }
 }
diff --git a/ReelAI/ViewModels/VideoManagementViewModel.swift b/ReelAI/ViewModels/VideoManagementViewModel.swift
index 825fccb..96e1756 100644
--- a/ReelAI/ViewModels/VideoManagementViewModel.swift
+++ b/ReelAI/ViewModels/VideoManagementViewModel.swift
@@ -9,7 +9,7 @@ final class VideoManagementViewModel: ObservableObject {
     private let databaseManager: DatabaseManager
     private let logger: Logger
 
-    init(databaseManager: DatabaseManager = FirebaseDatabaseManager()) {
+    init(databaseManager: DatabaseManager) {
         self.databaseManager = databaseManager
         self.logger = Logger(
             subsystem: Bundle.main.bundleIdentifier ?? "ReelAI",
@@ -17,6 +17,12 @@ final class VideoManagementViewModel: ObservableObject {
         )
     }
 
+    // Convenience initializer that handles actor isolation
+    @MainActor
+    static func create() -> VideoManagementViewModel {
+        return VideoManagementViewModel(databaseManager: FirebaseDatabaseManager.shared)
+    }
+
     func softDelete(_ video: Video) async {
         isLoading = true
         error = nil
diff --git a/ReelAI/Views/EditProfileView.swift b/ReelAI/Views/EditProfileView.swift
index c0c9d0f..7beec0c 100644
--- a/ReelAI/Views/EditProfileView.swift
+++ b/ReelAI/Views/EditProfileView.swift
@@ -1,19 +1,25 @@
 import SwiftUI
 import FirebaseStorage
 import FirebaseDatabase
+import FirebaseAuth
 
+@MainActor
 struct EditProfileView: View {
     @Environment(\.dismiss) private var dismiss
     @StateObject private var viewModel: EditProfileViewModel
     @State private var showingPhotoPicker = false
 
+    @MainActor
     init(profile: UserProfile,
-         storage: StorageManager = FirebaseStorageManager(),
-         database: DatabaseManager = FirebaseDatabaseManager()) {
+         storage: StorageManager,
+         databaseManager: DatabaseManager,
+         authService: FirebaseAuthService) {
         _viewModel = StateObject(wrappedValue: EditProfileViewModel(
             profile: profile,
             storage: storage,
-            database: database
+            database: databaseManager,
+            authService: authService,
+            databaseManager: databaseManager
         ))
     }
 
@@ -95,29 +101,53 @@ private struct PhotoSelectorButton: View {
 
     var body: some View {
         Button(action: action) {
-            HStack {
-                AsyncImage(url: photoURL) { image in
-                    image
-                        .resizable()
-                        .scaledToFill()
+            ZStack(alignment: .bottomTrailing) {
+                // Use AsyncImage with cache-busting technique
+                AsyncImage(url: photoWithTimestamp) { image in
+                    image.resizable()
+                         .aspectRatio(contentMode: .fill)
+                         .frame(width: 120, height: 120)
+                         .clipShape(Circle())
                 } placeholder: {
-                    Color.gray.opacity(0.2)
-                }
-                .frame(width: 60, height: 60)
-                .clipShape(Circle())
-                .overlay {
-                    if isLoading {
-                        ProgressView()
-                            .background(.ultraThinMaterial)
-                            .clipShape(Circle())
-                    }
+                    Image(systemName: "person.circle.fill")
+                        .resizable()
+                        .aspectRatio(contentMode: .fill)
+                        .frame(width: 120, height: 120)
+                        .foregroundColor(.gray)
                 }
 
-                Text("Change Photo")
-                    .foregroundColor(.accentColor)
+                if isLoading {
+                    ProgressView()
+                        .progressViewStyle(CircularProgressViewStyle(tint: .white))
+                        .frame(width: 30, height: 30)
+                        .background(Color.black.opacity(0.5))
+                        .clipShape(Circle())
+                        .offset(x: -10, y: -10)
+                } else {
+                    Image(systemName: "pencil.circle.fill")
+                        .resizable()
+                        .frame(width: 30, height: 30)
+                        .background(Color.white)
+                        .clipShape(Circle())
+                        .offset(x: -10, y: -10)
+                }
             }
         }
     }
+
+    // Add a timestamp to force image refresh
+    private var photoWithTimestamp: URL? {
+        guard let photoURL = photoURL,
+              var urlComponents = URLComponents(url: photoURL, resolvingAgainstBaseURL: false) else {
+            return photoURL
+        }
+
+        // Add a timestamp query parameter to force refresh
+        let timestampQuery = URLQueryItem(name: "timestamp", value: "\(Date().timeIntervalSince1970)")
+        urlComponents.queryItems = (urlComponents.queryItems ?? []) + [timestampQuery]
+
+        return urlComponents.url
+    }
 }
 
 private struct SocialLinkRow: View {
diff --git a/ReelAI/Views/Feed/VideoFeedView.swift b/ReelAI/Views/Feed/VideoFeedView.swift
index 7da094e..6477725 100644
--- a/ReelAI/Views/Feed/VideoFeedView.swift
+++ b/ReelAI/Views/Feed/VideoFeedView.swift
@@ -1,189 +1,80 @@
 import SwiftUI
 import AVKit
-import UIKit
+import os
 
 @MainActor
 struct VideoFeedView: View {
-    @StateObject private var viewModel: VideoFeedViewModel
-    @State private var dragOffset: CGFloat = 0
-    @State private var isDragging: Bool = false
-    @Environment(\.scenePhase) private var scenePhase
-
-    init(viewModel: VideoFeedViewModel? = nil) {
-        let vm = viewModel ?? VideoFeedViewModel()
-        _viewModel = StateObject(wrappedValue: vm)
-    }
-
+    @StateObject private var viewModel = VideoFeedViewModel()
+    @State private var isMuted = true
+    @GestureState private var dragOffset: CGFloat = 0
+    
     var body: some View {
-        GeometryReader { _ in
+        GeometryReader { geometry in
             ZStack {
-                Color.black.ignoresSafeArea()
+                Color.black.edgesIgnoringSafeArea(.all)
                 
-                if viewModel.isLoading && viewModel.videos.isEmpty {
-                    loadingView
-                } else if !viewModel.videos.isEmpty {
-                    videoFeedContent(in: GeometryProxy())
-                } else if let error = viewModel.error {
-                    errorView(error)
+                if let currentVideo = viewModel.currentVideo {
+                    VideoPlayerView(video: currentVideo, isMuted: isMuted)
+                        .offset(y: dragOffset)
+                        .animation(.easeInOut(duration: 0.3), value: dragOffset)
+                        .gesture(
+                            DragGesture()
+                                .updating($dragOffset) { value, state, _ in
+                                    state = value.translation.height
+                                }
+                                .onEnded { value in
+                                    let height = geometry.size.height
+                                    let threshold = height * 0.25
+                                    let velocity = value.predictedEndLocation.y - value.location.y
+                                    
+                                    withAnimation(.easeInOut(duration: 0.3)) {
+                                        if abs(value.translation.height) > threshold || abs(velocity) > 500 {
+                                            if value.translation.height > 0 {
+                                                viewModel.moveToPrevious()
+                                            } else {
+                                                viewModel.moveToNext()
+                                            }
+                                        }
+                                    }
+                                }
+                        )
                 }
-            }
-            .onChange(of: scenePhase) { _, newPhase in
-                Task { @MainActor in
-                    await handleScenePhaseChange(newPhase)
-                }
-            }
-            .task {
-                if viewModel.videos.isEmpty {
-                    await viewModel.loadVideos()
+                
+                // Preload next video
+                if let nextVideo = viewModel.nextVideo {
+                    VideoPlayerView(video: nextVideo, isMuted: isMuted, isPreloading: true)
+                        .opacity(0)
                 }
-            }
-            .navigationBarHidden(true)
-        }
-    }
-    
-    @ViewBuilder
-    private func videoFeedContent(in geometry: GeometryProxy) -> some View {
-        GeometryReader { _ in
-            ScrollViewReader { proxy in
-                ScrollView(.vertical, showsIndicators: false) {
-                    LazyVStack(spacing: 0) {
-                        ForEach(viewModel.videos) { video in
-                            videoCell(for: video, in: geometry)
-                                .id(video.id)
+                
+                // UI Overlay
+                VStack {
+                    HStack {
+                        Button(action: { isMuted.toggle() }) {
+                            Image(systemName: isMuted ? "speaker.slash.fill" : "speaker.wave.2.fill")
+                                .foregroundColor(.white)
+                                .padding()
                         }
+                        Spacer()
                     }
+                    Spacer()
                 }
-                .scrollDisabled(true)
-                .highPriorityGesture(createDragGesture(proxy: proxy))
-                .onAppear {
-                    if viewModel.currentlyPlayingId == nil {
-                        viewModel.currentlyPlayingId = viewModel.videos.first?.id
-                    }
+                
+                if viewModel.isLoading {
+                    ProgressView()
+                        .progressViewStyle(CircularProgressViewStyle(tint: .white))
+                        .scaleEffect(1.5)
                 }
             }
         }
-    }
-    
-    private func videoCell(for video: Video, in geometry: GeometryProxy) -> some View {
-        let isCurrentVideo = viewModel.currentlyPlayingId == video.id
-        return VideoPlayerView(
-            videoURL: video.videoURL,
-            videoId: video.id,
-            feedViewModel: viewModel,
-            isPlaying: isCurrentVideo
-        )
-        .frame(width: geometry.size.width, height: geometry.size.height)
-        .offset(y: calculateOffset(for: video, dragOffset: dragOffset, in: geometry))
-        .opacity(isCurrentVideo ? 1 : 0)
-    }
-    
-    private func createDragGesture(proxy: ScrollViewProxy) -> some Gesture {
-        DragGesture(minimumDistance: 10)
-            .onChanged { value in
-                handleDragChange(value)
-            }
-            .onEnded { value in
-                handleDragEnd(value, proxy: proxy)
-            }
-    }
-    
-    private func handleDragChange(_ value: DragGesture.Value) {
-        guard let currentIndex = viewModel.videos.firstIndex(where: { $0.id == viewModel.currentlyPlayingId }) else {
-            return
-        }
-        
-        isDragging = true
-        let translation = value.translation.height
-        let screenHeight = UIScreen.main.bounds.height
-        
-        // Update drag offset with resistance
-        let threshold = screenHeight * 0.3
-        if abs(translation) > threshold {
-            let excess = abs(translation) - threshold
-            let damping = 0.2
-            let dampedExcess = excess * damping
-            dragOffset = (translation < 0 ? -1 : 1) * (threshold + dampedExcess)
-        } else {
-            dragOffset = translation
+        .task {
+            await viewModel.loadVideos()
         }
     }
-    
-    private func handleDragEnd(_ value: DragGesture.Value, proxy: ScrollViewProxy) {
-        guard let currentIndex = viewModel.videos.firstIndex(where: { $0.id == viewModel.currentlyPlayingId }) else {
-            return
-        }
-        
-        isDragging = false
-        let translation = value.translation.height
-        let progress = translation / UIScreen.main.bounds.height
-        
-        if abs(progress) >= 0.2 {
-            let nextIndex = progress > 0 ? 
-                max(0, currentIndex - 1) : 
-                min(viewModel.videos.count - 1, currentIndex + 1)
-            
-            withAnimation(.spring(response: 0.3, dampingFraction: 0.8)) {
-                dragOffset = 0
-                viewModel.currentlyPlayingId = viewModel.videos[nextIndex].id
-                proxy.scrollTo(viewModel.videos[nextIndex].id, anchor: .center)
-            }
-        } else {
-            withAnimation(.spring(response: 0.3, dampingFraction: 0.8)) {
-                dragOffset = 0
-                proxy.scrollTo(viewModel.videos[currentIndex].id, anchor: .center)
-            }
-        }
-    }
-    
-    private func handleScenePhaseChange(_ newPhase: ScenePhase) async {
-        switch newPhase {
-        case .background:
-            await viewModel.handleBackground()
-        case .active:
-            await viewModel.handleForeground()
-        default:
-            break
-        }
-    }
-    
-    private func calculateOffset(for video: Video, dragOffset: CGFloat, in geometry: GeometryProxy) -> CGFloat {
-        guard let currentIndex = viewModel.videos.firstIndex(where: { $0.id == viewModel.currentlyPlayingId }),
-              let videoIndex = viewModel.videos.firstIndex(where: { $0.id == video.id }) else {
-            return 0
-        }
-        
-        let screenHeight = geometry.size.height
-        let indexDiff = CGFloat(videoIndex - currentIndex)
-        let baseOffset = indexDiff * screenHeight
-        return baseOffset + dragOffset
-    }
-    
-    @ViewBuilder
-    private var loadingView: some View {
-        VStack(spacing: 16) {
-            ProgressView()
-                .progressViewStyle(CircularProgressViewStyle(tint: .white))
-                .scaleEffect(1.5)
-            Text("Loading videos...")
-                .foregroundColor(.white)
-        }
-    }
-    
-    @ViewBuilder
-    private func errorView(_ error: String) -> some View {
-        VStack(spacing: 16) {
-            Text(error)
-                .foregroundColor(.white)
-            Button("Retry") {
-                Task {
-                    await viewModel.loadVideos()
-                }
-            }
-            .foregroundColor(.white)
-            .padding()
-            .background(Color.gray.opacity(0.3))
-            .cornerRadius(8)
-        }
+}
+
+extension Collection {
+    subscript(safe index: Index) -> Element? {
+        indices.contains(index) ? self[index] : nil
     }
 }
 
@@ -194,24 +85,4 @@ struct VideoFeedView_Previews: PreviewProvider {
         VideoFeedView()
     }
 }
-
-struct VideoFeedViewLoading_Previews: PreviewProvider {
-    static var previews: some View {
-        VideoFeedView(viewModel: {
-            let vm = VideoFeedViewModel()
-            vm.setLoading(true)
-            return vm
-        }())
-    }
-}
-
-struct VideoFeedViewError_Previews: PreviewProvider {
-    static var previews: some View {
-        VideoFeedView(viewModel: {
-            let vm = VideoFeedViewModel()
-            vm.setError("Network connection unavailable")
-            return vm
-        }())
-    }
-}
 #endif
diff --git a/ReelAI/Views/Player/PlayerViewModel.swift b/ReelAI/Views/Player/PlayerViewModel.swift
index 7dc2835..d1bb81f 100644
--- a/ReelAI/Views/Player/PlayerViewModel.swift
+++ b/ReelAI/Views/Player/PlayerViewModel.swift
@@ -6,6 +6,9 @@ final class PlayerViewModel: NSObject, ObservableObject {
     @Published var player: AVPlayer?
     @Published var isReadyToPlay = false
     @Published var progress: Double = 0
+    @Published var isLoading = true
+    @Published var hasError = false
+
     private var shouldLoop = true
     private let logger = Logger(subsystem: Bundle.main.bundleIdentifier ?? "ReelAI", category: "PlayerViewModel")
 
@@ -16,19 +19,70 @@ final class PlayerViewModel: NSObject, ObservableObject {
     private var boundaryObserver: Any?
 
     private var wasPlayingBeforeBackground = false
+    private var currentVideoURL: URL?
+
+    // Preloading configuration
+    private let preloadBuffer: TimeInterval = 10.0  // 10 seconds ahead
+    private var preloadTask: Task<Void, Never>?
 
-    func configurePlayback(shouldLoop: Bool) {
+    func configurePlayback(shouldLoop: Bool = true, preloadAhead: Bool = true) {
         self.shouldLoop = shouldLoop
+        if preloadAhead {
+            setupPreloading()
+        }
+    }
+
+    private func setupPreloading() {
+        // Removed setupPreloading function
+    }
+
+    private func preloadVideo(asset: AVURLAsset) async {
+        do {
+            // Get duration
+            let duration = try await asset.load(.duration)
+
+            // Preload next buffer
+            let preloadTime = min(duration.seconds, preloadBuffer)
+
+            // Check media selection options (if needed)
+            if #available(iOS 16.0, *) {
+                if let audibleGroup = try? await asset.loadMediaSelectionGroup(for: .audible) {
+                    logger.debug("Audible media options: \(audibleGroup.options)")
+                }
+            } else {
+                let characteristics = try await asset.load(.availableMediaCharacteristicsWithMediaSelectionOptions)
+                if characteristics.contains(.audible),
+                   let audibleGroup = asset.mediaSelectionGroup(forMediaCharacteristic: .audible) {
+                    logger.debug("Audible media options: \(audibleGroup.options)")
+                }
+            }
+
+            logger.debug(" Preloaded \(preloadTime) seconds of video")
+        } catch {
+            logger.error(" Preloading failed: \(error.localizedDescription)")
+        }
     }
 
     func loadVideo(url: URL) {
-        loadVideo(playerItem: AVPlayerItem(url: url))
+        // Cancel any existing preload task
+        preloadTask?.cancel()
+        currentVideoURL = url
+
+        let playerItem = AVPlayerItem(url: url)
+        loadVideo(playerItem: playerItem)
+
+        // Start preloading asynchronously
+        let asset = AVURLAsset(url: url)
+        preloadTask = Task {
+            await preloadVideo(asset: asset)
+        }
     }
 
     func loadVideo(playerItem: AVPlayerItem) {
         let startTime = CFAbsoluteTimeGetCurrent()
-        self.logger.debug("🎬 Starting video load: \(CFAbsoluteTimeGetCurrent())")
+        logger.debug(" Starting video load: \(startTime)")
 
+        // Enhanced buffering
         playerItem.preferredForwardBufferDuration = 10
         playerItem.automaticallyPreservesTimeOffsetFromLive = false
 
@@ -39,6 +93,8 @@ final class PlayerViewModel: NSObject, ObservableObject {
 
     private func setupInitialState(_ playerItem: AVPlayerItem) {
         isReadyToPlay = false
+        isLoading = true
+        hasError = false
         player = AVPlayer(playerItem: playerItem)
     }
 
@@ -55,7 +111,7 @@ final class PlayerViewModel: NSObject, ObservableObject {
             Task { @MainActor in
                 if item.isPlaybackLikelyToKeepUp {
                     let elapsed = CFAbsoluteTimeGetCurrent() - startTime
-                    self?.logger.debug("📺 Video playback ready: \(elapsed) seconds")
+                    self?.logger.debug(" Video playback ready: \(elapsed) seconds")
                     self?.handleReadyToPlay()
                 }
             }
@@ -94,7 +150,7 @@ final class PlayerViewModel: NSObject, ObservableObject {
             queue: .main
         ) { [weak self] _ in
             Task { @MainActor in
-                self?.logger.debug("📼 Video playback ended")
+                self?.logger.debug(" Video playback ended")
                 self?.handlePlaybackEnd()
             }
         }
@@ -120,13 +176,31 @@ final class PlayerViewModel: NSObject, ObservableObject {
 
     private func handlePlaybackEnd() {
         guard shouldLoop else { return }
-        player?.seek(to: .zero)
-        player?.play()
-        progress = 0
+
+        // More robust looping
+        Task { @MainActor in
+            self.player?.seek(to: .zero)
+            self.player?.play()
+            self.progress = 0
+            self.logger.debug(" Video looped")
+        }
     }
 
     private func handlePlaybackError() {
-        self.logger.error("❌ Playback failed")
+        logger.error(" Playback failed")
+        hasError = true
+        isLoading = false
+        isReadyToPlay = false
+    }
+
+    private func handleReadyToPlay() {
+        guard !isReadyToPlay else { return }
+
+        isReadyToPlay = true
+        isLoading = false
+        player?.play()
+
+        logger.debug(" Video ready to play")
     }
 
     @available(iOS 16.0, *)
@@ -142,7 +216,7 @@ final class PlayerViewModel: NSObject, ObservableObject {
                     }
                 }
             } catch {
-                self.logger.error("❌ Failed to load asset: \(error.localizedDescription)")
+                self.logger.error(" Failed to load asset: \(error.localizedDescription)")
             }
         }
     }
@@ -159,12 +233,6 @@ final class PlayerViewModel: NSObject, ObservableObject {
         }
     }
 
-    private func handleReadyToPlay() {
-        guard !isReadyToPlay else { return }
-        isReadyToPlay = true
-        player?.play()
-    }
-
     func cleanup() {
         statusObserver?.invalidate()
         readyForDisplayObserver?.invalidate()
diff --git a/ReelAI/Views/Player/VideoPlayerView.swift b/ReelAI/Views/Player/VideoPlayerView.swift
index b6ab11c..bfa1622 100644
--- a/ReelAI/Views/Player/VideoPlayerView.swift
+++ b/ReelAI/Views/Player/VideoPlayerView.swift
@@ -1,116 +1,115 @@
 import SwiftUI
 import AVKit
+import os
 
-struct VideoPlayerView: View {
-    let videoURL: URL
-    let videoId: String
-    let feedViewModel: VideoFeedViewModel
-    let isPlaying: Bool
+class PlayerObserver: ObservableObject {
+    private let logger = Logger(subsystem: Bundle.main.bundleIdentifier ?? "ReelAI", category: "PlayerObserver")
+    private var timeObserver: Any?
+    private var statusObserver: NSKeyValueObservation?
+    private var loadedRangesObserver: NSKeyValueObservation?
+    private var player: AVPlayer?
     
-    @State private var player: AVPlayer?
-    @State private var isLoaded = false
-    @State private var playerState = PlayerState()
-    @State private var observation: NSKeyValueObservation?
+    @Published var isReady = false
+    @Published var isPreloaded = false
+    @Published var bufferingProgress: Double = 0
     
-    var body: some View {
-        GeometryReader { _ in
-            ZStack {
-                if let player = player, isLoaded {
-                    VideoPlayer(player: player)
-                        .edgesIgnoringSafeArea(.all)
-                        .disabled(true)
-                } else {
-                    Color.black
-                }
-                
-                // Loading indicator
-                if !isLoaded {
-                    ProgressView()
-                        .progressViewStyle(CircularProgressViewStyle(tint: .white))
-                        .scaleEffect(1.5)
-                }
-            }
-            .onAppear {
-                print("🎥 VideoPlayerView appeared for \(videoId)")
-                if player == nil {
-                    setupPlayer()
+    init(player: AVPlayer, videoId: String) {
+        self.player = player
+        setupObservers(for: player, videoId: videoId)
+    }
+    
+    private func setupObservers(for player: AVPlayer, videoId: String) {
+        statusObserver = player.currentItem?.observe(\.status) { [weak self] item, _ in
+            DispatchQueue.main.async {
+                if item.status == .readyToPlay {
+                    self?.isReady = true
                 }
             }
-            .onDisappear {
-                print("🎥 VideoPlayerView disappeared for \(videoId)")
-                cleanupPlayer()
+        }
+        
+        loadedRangesObserver = player.currentItem?.observe(\.loadedTimeRanges) { [weak self] item, _ in
+            let duration = item.duration.seconds
+            guard duration.isFinite,
+                  duration > 0,
+                  !duration.isNaN else { return }
+            
+            let loadedDuration = item.loadedTimeRanges.reduce(0.0) { total, range in
+                let timeRange = range.timeRangeValue
+                return total + timeRange.duration.seconds
             }
-            .onChange(of: isPlaying) { _, playing in
-                handlePlaybackChange(playing)
+            DispatchQueue.main.async {
+                self?.bufferingProgress = loadedDuration / duration
+                self?.isPreloaded = loadedDuration / duration >= 0.95
             }
         }
-        .edgesIgnoringSafeArea(.all)
-        .background(Color.black)
+        
+        NotificationCenter.default.addObserver(forName: .AVPlayerItemDidPlayToEndTime,
+                                             object: player.currentItem,
+                                             queue: .main) { [weak player] _ in
+            player?.seek(to: .zero)
+            player?.play()
+        }
     }
     
-    private func handlePlaybackChange(_ playing: Bool) {
-        guard let player = player, isLoaded else {
-            print("🎥 Player not ready for playback change on \(videoId)")
-            return
-        }
-        
-        if playing {
-            print("🎥 Starting playback for \(videoId)")
-            player.seek(to: .zero)
-            player.play()
-            playerState.isPlaying = true
-        } else {
-            print("🎥 Pausing playback for \(videoId)")
-            player.pause()
-            playerState.isPlaying = false
+    deinit {
+        if let timeObserver = timeObserver {
+            player?.removeTimeObserver(timeObserver)
         }
+        statusObserver?.invalidate()
+        loadedRangesObserver?.invalidate()
+        NotificationCenter.default.removeObserver(self)
     }
+}
+
+struct VideoPlayerView: View {
+    let video: Video
+    let isMuted: Bool
+    let isPreloading: Bool
+    @StateObject private var observer: PlayerObserver
+    private let player: AVPlayer
     
-    private func setupPlayer() {
-        print("🎥 Setting up player for \(videoId)")
+    init(video: Video, isMuted: Bool = false, isPreloading: Bool = false) {
+        self.video = video
+        self.isMuted = isMuted
+        self.isPreloading = isPreloading
         
-        // Create player and item
-        let player = AVPlayer(url: videoURL)
+        let player = AVPlayer(url: video.videoURL)
+        player.isMuted = isMuted
+        player.actionAtItemEnd = .none
         player.automaticallyWaitsToMinimizeStalling = false
         
-        // Store the player first
-        self.player = player
-        
-        // Add observer for loading status
-        observation = player.currentItem?.observe(\.status) { item, _ in
-            Task { @MainActor in
-                switch item.status {
-                case .readyToPlay:
-                    print("🎥 Player ready for \(videoId)")
-                    isLoaded = true
-                    if isPlaying {
-                        player.play()
-                        playerState.isPlaying = true
-                    }
-                case .failed:
-                    print("❌ Player failed for \(videoId): \(String(describing: item.error))")
-                default:
-                    break
-                }
-            }
+        // Preload video if specified
+        if isPreloading {
+            let item = player.currentItem
+            item?.preferredForwardBufferDuration = 10
+            player.preroll(atRate: 1) { _ in }
         }
         
-        // Enable audio session
-        do {
-            try AVAudioSession.sharedInstance().setCategory(.playback, mode: .default)
-            try AVAudioSession.sharedInstance().setActive(true)
-        } catch {
-            print("❌ Failed to set audio session: \(error)")
-        }
+        _observer = StateObject(wrappedValue: PlayerObserver(player: player, videoId: video.id))
+        self.player = player
     }
     
-    private func cleanupPlayer() {
-        print("🎥 Cleaning up player for \(videoId)")
-        player?.pause()
-        observation?.invalidate()
-        observation = nil
-        player = nil
-        isLoaded = false
-        playerState.isPlaying = false
+    var body: some View {
+        VideoPlayer(player: player)
+            .opacity(observer.isReady ? 1 : 0)
+            .overlay {
+                if !observer.isReady {
+                    ProgressView()
+                        .progressViewStyle(CircularProgressViewStyle(tint: .white))
+                        .scaleEffect(1.5)
+                }
+            }
+            .onAppear {
+                if !isPreloading {
+                    player.play()
+                }
+            }
+            .onDisappear {
+                player.pause()
+                if !isPreloading {
+                    player.replaceCurrentItem(with: nil)
+                }
+            }
+            .animation(.easeInOut, value: observer.isReady)
     }
 }
diff --git a/ReelAI/Views/ProfileView.swift b/ReelAI/Views/ProfileView.swift
index 6f028a5..a9e4297 100644
--- a/ReelAI/Views/ProfileView.swift
+++ b/ReelAI/Views/ProfileView.swift
@@ -3,10 +3,15 @@ import os  // For logging
 import FirebaseAuth  // For auth types
 
 struct ProfileView: View {
-    @StateObject private var viewModel: ProfileViewModel
-    @EnvironmentObject private var authViewModel: AuthViewModel
+    @StateObject private var viewModel = ProfileViewModel(
+        authService: FirebaseAuthService(),
+        storage: FirebaseStorageManager(),
+        database: FirebaseDatabaseManager.shared
+    )
     @State private var isEditingProfile = false
     @State private var selectedVideoForEdit: Video?
+    @State private var isSignedOut = false
+    @State private var signOutError: Error?
 
     private let columns = [
         GridItem(.flexible()),
@@ -15,126 +20,175 @@ struct ProfileView: View {
     ]
     private let logger = Logger(subsystem: Bundle.main.bundleIdentifier ?? "ReelAI", category: "ProfileView")
 
-    init(viewModel: ProfileViewModel? = nil) {
-        let wrappedValue = viewModel ?? ProfileViewModel(
-            authService: FirebaseAuthService()
-        )
-        _viewModel = StateObject(wrappedValue: wrappedValue)
+    var body: some View {
+        if isSignedOut {
+            signedOutView
+        } else {
+            mainProfileContent
+                .navigationDestination(item: $selectedVideoForEdit) { video in
+                    VideoManagementView(video: video)
+                }
+                .refreshable {
+                    await viewModel.forceRefreshVideos()
+                    await viewModel.forceRefreshProfilePhoto()
+                }
+                .task {
+                    await viewModel.loadVideos()
+                }
+                .onChange(of: viewModel.profile.photoURL) { _, _ in
+                    Task {
+                        await viewModel.forceRefreshProfilePhoto()
+                    }
+                }
+                .sheet(isPresented: $isEditingProfile) {
+                    EditProfileView(
+                        profile: viewModel.profile,
+                        storage: viewModel.storageManager,
+                        databaseManager: viewModel.databaseManager,
+                        authService: FirebaseAuthService()
+                    )
+                }
+                .alert(isPresented: Binding<Bool>(
+                    get: { signOutError != nil },
+                    set: { _ in signOutError = nil }
+                )) {
+                    Alert(
+                        title: Text("Sign Out Error"),
+                        message: Text(signOutError?.localizedDescription ?? "Unable to sign out"),
+                        dismissButton: .default(Text("OK"))
+                    )
+                }
+        }
     }
 
-    var body: some View {
-        NavigationStack {
+    private var signedOutView: some View {
+        Text("Signed Out")
+            .transition(.opacity)
+    }
+
+    private var mainProfileContent: some View {
+        NavigationView {
             ScrollView {
                 VStack(spacing: 20) {
-                    // Profile Header
-                    VStack(spacing: 16) {
-                        // Profile Image
-                        if let photoURL = viewModel.profile.photoURL {
-                            AsyncImage(url: photoURL) { image in
-                                image
-                                    .resizable()
-                                    .scaledToFill()
-                            } placeholder: {
-                                Image(systemName: "person.circle.fill")
-                                    .resizable()
-                            }
-                            .frame(width: 80, height: 80)
-                            .clipShape(Circle())
-                        } else {
-                            Image(systemName: "person.circle.fill")
-                                .resizable()
-                                .frame(width: 80, height: 80)
-                                .foregroundColor(.gray)
-                        }
-
-                        // Name and Edit Button
-                        HStack {
-                            Text(viewModel.profile.displayName)
-                                .font(.title2)
-                                .bold()
-
-                            Button {
-                                isEditingProfile = true
-                            } label: {
-                                Image(systemName: "pencil.circle")
-                                    .font(.title2)
-                            }
-                        }
-                    }
-                    .padding(.top)
-
-                    // Videos Grid
-                    if viewModel.isLoading && viewModel.videos.isEmpty {
-                        LazyVGrid(columns: columns, spacing: 1) {
-                            ForEach(0..<12, id: \.self) { _ in
-                                Color.gray.opacity(0.3)
-                                    .aspectRatio(9/16, contentMode: .fill)
-                            }
-                        }
-                        .padding(1)
-                    } else {
-                        LazyVGrid(columns: columns, spacing: 1) {
-                            ForEach(viewModel.videos) { video in
-                                ProfileGridItem(
-                                    video: video,
-                                    selectedVideoForEdit: $selectedVideoForEdit,
-                                    viewModel: viewModel
-                                )
-                                .id("\(video.id)-\(video.isDeleted)-\(video.lastEditedAt?.timeIntervalSince1970 ?? 0)")
-                            }
-                        }
-                        .padding(1)
-                    }
+                    profileHeaderSection
+                    videosGridSection
                 }
             }
             .navigationTitle("Profile")
             .navigationBarTitleDisplayMode(.inline)
             .toolbar {
                 ToolbarItem(placement: .navigationBarTrailing) {
-                    Menu {
-                        Button(role: .destructive) {
-                            Task {
-                                authViewModel.signOut()
-                            }
-                        } label: {
-                            Label("Sign Out", systemImage: "rectangle.portrait.and.arrow.right")
-                        }
-                    } label: {
-                        Image(systemName: "ellipsis")
-                            .font(.title3)
-                    }
+                    profileOptionsMenu
                 }
             }
         }
-        .navigationDestination(item: $selectedVideoForEdit) { video in
-            VideoManagementView(video: video)
+    }
+
+    private var profileOptionsMenu: some View {
+        Menu {
+            Button(role: .destructive) {
+                do {
+                    try viewModel.authService.signOut()
+                    isSignedOut = true
+                } catch {
+                    signOutError = error
+                }
+            } label: {
+                Label("Sign Out", systemImage: "rectangle.portrait.and.arrow.right")
+            }
+        } label: {
+            Image(systemName: "ellipsis")
+                .font(.title3)
         }
-        .refreshable {
-            await viewModel.forceRefreshVideos()
+    }
+
+    private var profileHeaderSection: some View {
+        VStack(spacing: 15) {
+            // Profile Photo with Cache-Busting
+            AsyncImage(url: photoWithTimestamp) { image in
+                image
+                    .resizable()
+                    .aspectRatio(contentMode: .fill)
+                    .frame(width: 120, height: 120)
+                    .clipShape(Circle())
+                    .overlay(
+                        Circle().stroke(Color.white, lineWidth: 4)
+                            .shadow(radius: 7)
+                    )
+            } placeholder: {
+                Image(systemName: "person.circle.fill")
+                    .resizable()
+                    .aspectRatio(contentMode: .fill)
+                    .frame(width: 120, height: 120)
+                    .foregroundColor(.gray)
+            }
+
+            profileNameAndEditButton
         }
-        .task {
-            await viewModel.loadVideos()
+        .padding(.top)
+    }
+
+    // Add a timestamp to force image refresh
+    private var photoWithTimestamp: URL? {
+        guard let photoURL = viewModel.profile.photoURL,
+              var urlComponents = URLComponents(url: photoURL, resolvingAgainstBaseURL: false) else {
+            return viewModel.profile.photoURL
         }
-        .onChange(of: authViewModel.isAuthenticated) { _, _ in
-            Task {
-                await viewModel.forceRefreshVideos()
+
+        // Add a timestamp query parameter to force refresh
+        let timestampQuery = URLQueryItem(name: "timestamp", value: "\(Date().timeIntervalSince1970)")
+        urlComponents.queryItems = (urlComponents.queryItems ?? []) + [timestampQuery]
+
+        return urlComponents.url
+    }
+
+    private var profileNameAndEditButton: some View {
+        HStack {
+            Text(viewModel.profile.displayName)
+                .font(.title2)
+                .bold()
+
+            Button {
+                isEditingProfile = true
+            } label: {
+                Image(systemName: "pencil.circle")
+                    .font(.title2)
             }
         }
-        .onChange(of: selectedVideoForEdit) { _, video in
-            if let video = video {
-                logger.debug("📝 Navigation triggered for video: \(video.id)")
+    }
+
+    private var videosGridSection: some View {
+        Group {
+            if viewModel.isLoading && viewModel.videos.isEmpty {
+                loadingPlaceholder
+            } else {
+                videoGridContent
             }
         }
-        .onChange(of: viewModel.videos) { _, _ in
-            logger.debug("📱 Videos updated in view, count: \(viewModel.videos.count)")
+    }
+
+    private var loadingPlaceholder: some View {
+        LazyVGrid(columns: columns, spacing: 1) {
+            ForEach(0..<12, id: \.self) { _ in
+                Color.gray.opacity(0.3)
+                    .aspectRatio(9/16, contentMode: .fill)
+            }
         }
-        .sheet(isPresented: $isEditingProfile) {
-            EditProfileView(
-                profile: viewModel.profile,
-                storage: viewModel.storageManager,
-                database: viewModel.databaseManager
-            )
+        .padding(1)
+    }
+
+    private var videoGridContent: some View {
+        LazyVGrid(columns: columns, spacing: 1) {
+            ForEach(viewModel.videos) { video in
+                ProfileGridItem(
+                    video: video,
+                    selectedVideoForEdit: $selectedVideoForEdit,
+                    viewModel: viewModel
+                )
+                .id("\(video.id)-\(video.isDeleted)-\(video.lastEditedAt?.timeIntervalSince1970 ?? 0)")
+            }
         }
+        .padding(1)
     }
 }
 
@@ -144,7 +198,7 @@ private extension ProfileView {
         let video: Video
         @Binding var selectedVideoForEdit: Video?
         @ObservedObject var viewModel: ProfileViewModel
-        private let logger = Logger(subsystem: Bundle.main.bundleIdentifier ?? "ReelAI", category: "ProfileGridItem")
+        private let logger: Logger = Logger(subsystem: Bundle.main.bundleIdentifier ?? "ReelAI", category: "ProfileGridItem")
 
         var body: some View {
             VideoThumbnailView(video: video)
diff --git a/ReelAI/Views/Upload/VideoUploadView.swift b/ReelAI/Views/Upload/VideoUploadView.swift
index 6c3718e..305d64e 100644
--- a/ReelAI/Views/Upload/VideoUploadView.swift
+++ b/ReelAI/Views/Upload/VideoUploadView.swift
@@ -7,77 +7,104 @@ struct VideoUploadView: View {
     @Environment(\.dismiss) private var dismiss
     @State private var showingQualityPicker = false
 
+    private var computedThumbnails: [UIImage] {
+        let selectedURLs: [URL] = viewModel.selectedVideoURLs
+        let thumbnailsDict: [URL: UIImage] = viewModel.thumbnails
+        var thumbnails: [UIImage] = []
+        for url in selectedURLs {
+            if let image = thumbnailsDict[url] {
+                thumbnails.append(image)
+            }
+        }
+        return thumbnails
+    }
+
+    private var previewSection: some View {
+        MultiVideoPreviewSection(
+            thumbnails: computedThumbnails,
+            onTap: { showingPhotoPicker = true }
+        )
+    }
+
+    private var uploadStack: some View {
+        VStack(spacing: 20) {
+            previewSection
+            CaptionInputField(
+                caption: $viewModel.caption,
+                isEnabled: !viewModel.isUploading
+            )
+
+            if !viewModel.selectedVideoURLs.isEmpty {
+                Text("Selected Videos: \(viewModel.selectedVideoURLs.count)")
+                    .foregroundColor(.secondary)
+            }
+
+            UploadProgressSection(
+                isUploading: viewModel.isUploading,
+                progress: viewModel.uploadProgress,
+                onCancel: { viewModel.cancelUpload() }
+            )
+            .allowsHitTesting(true)
+
+            UploadButton(
+                isUploading: viewModel.isUploading,
+                hasVideo: !viewModel.selectedVideoURLs.isEmpty,
+                action: viewModel.uploadVideos
+            )
+
+            if let error = viewModel.errorMessage {
+                Text(error)
+                    .foregroundColor(error.hasPrefix("✅") ? .green : .red)
+                    .padding()
+            }
+
+            Spacer()
+        }
+    }
+
     var body: some View {
         NavigationView {
-            ZStack {  // Add ZStack to layer views
-                VStack(spacing: 20) {
-                    VideoPreviewSection(
-                        thumbnail: viewModel.thumbnailImage,
-                        onTap: { showingPhotoPicker = true }
-                    )
-                    CaptionInputField(
-                        caption: $viewModel.caption,
-                        isEnabled: !viewModel.isUploading
-                    )
-                    UploadProgressSection(
-                        isUploading: viewModel.isUploading,
-                        progress: viewModel.uploadProgress,
-                        onCancel: viewModel.cancelUpload
-                    )
-                    .allowsHitTesting(true)  // Allow interaction even when parent is disabled
-                    UploadButton(
-                        isUploading: viewModel.isUploading,
-                        hasVideo: viewModel.selectedVideoURL != nil,
-                        action: viewModel.uploadVideo
-                    )
-
-                    if let error = viewModel.errorMessage {
-                        Text(error)
-                            .foregroundColor(error.hasPrefix("✅") ? .green : .red)
-                            .padding()
-                    }
+            ZStack {
+                uploadStack
+            }
+            .navigationTitle("Upload Videos")
+            .navigationDestination(isPresented: $viewModel.shouldNavigateToProfile) {
+                ProfileView()
+            }
+            .sheet(isPresented: $showingPhotoPicker) {
+                VideoPicker(selectedVideoURLs: $viewModel.selectedVideoURLs, viewModel: viewModel)
+            }
+            .disabled(viewModel.isUploading && !viewModel.shouldNavigateToProfile)
 
+            // Overlay cancel button when uploading
+            if viewModel.isUploading {
+                VStack {
                     Spacer()
-                }
-                .navigationTitle("Upload Video")
-                .navigationDestination(isPresented: $viewModel.shouldNavigateToProfile) {
-                    ProfileView()
-                }
-                .sheet(isPresented: $showingPhotoPicker) {
-                    VideoPicker(viewModel: viewModel)
-                }
-                .disabled(viewModel.isUploading && !viewModel.shouldNavigateToProfile)
-
-                // Overlay cancel button when uploading
-                if viewModel.isUploading {
-                    VStack {
-                        Spacer()
-                        Button(action: {
-                            print("📱 Cancel button tapped in UI")
-                            viewModel.cancelUpload()
-                        }) {
-                            Text("Cancel Upload")
-                                .foregroundColor(.white)
-                                .padding(8)
-                                .background(Color.red.opacity(0.8))
-                                .cornerRadius(8)
-                        }
-                        .padding(.bottom, 40)
-                    }
-                    .onAppear {
-                        print("📱 Cancel overlay appeared")
+                    Button(action: {
+                        print("📱 Cancel button tapped in UI")
+                        viewModel.cancelUpload()
+                    }) {
+                        Text("Cancel Upload")
+                            .foregroundColor(.white)
+                            .padding(8)
+                            .background(Color.red.opacity(0.8))
+                            .cornerRadius(8)
                     }
+                    .padding(.bottom, 40)
                 }
-            }
-            .onChange(of: viewModel.shouldNavigateToProfile) { _, shouldNavigate in
-                if shouldNavigate {
-                    dismiss()
+                .onAppear {
+                    print("📱 Cancel overlay appeared")
                 }
             }
-            .onChange(of: viewModel.selectedVideoURL) { _, newValue in
-                if newValue != nil {
-                    showingQualityPicker = true
-                }
+        }
+        .onChange(of: viewModel.shouldNavigateToProfile) { _, shouldNavigate in
+            if shouldNavigate {
+                dismiss()
+            }
+        }
+        .onChange(of: viewModel.selectedVideoURLs) { _, newValue in
+            if !newValue.isEmpty {
+                showingQualityPicker = true
             }
         }
     }
@@ -85,18 +112,25 @@ struct VideoUploadView: View {
 
 // MARK: - Subviews
 
-struct VideoPreviewSection: View {
-    let thumbnail: UIImage?
+struct MultiVideoPreviewSection: View {
+    let thumbnails: [UIImage]
     let onTap: () -> Void
 
     var body: some View {
         Group {
-            if let thumbnail = thumbnail {
-                Image(uiImage: thumbnail)
-                    .resizable()
-                    .scaledToFit()
-                    .frame(height: 200)
-                    .cornerRadius(12)
+            if !thumbnails.isEmpty {
+                ScrollView(.horizontal, showsIndicators: false) {
+                    HStack(spacing: 10) {
+                        ForEach(thumbnails, id: \.self) { thumbnail in
+                            Image(uiImage: thumbnail)
+                                .resizable()
+                                .scaledToFit()
+                                .frame(height: 150)
+                                .cornerRadius(12)
+                        }
+                    }
+                    .padding(.horizontal)
+                }
             } else {
                 VideoPlaceholderView()
                     .onTapGesture(perform: onTap)
diff --git a/ReelAI/Views/VideoManagement/VideoManagementView.swift b/ReelAI/Views/VideoManagement/VideoManagementView.swift
index 90809fb..18169eb 100644
--- a/ReelAI/Views/VideoManagement/VideoManagementView.swift
+++ b/ReelAI/Views/VideoManagement/VideoManagementView.swift
@@ -9,9 +9,9 @@ struct VideoManagementView: View {
     @State private var editedCaption: String
     @State private var currentPrivacyLevel: Video.PrivacyLevel
 
-    init(video: Video, viewModel: VideoManagementViewModel? = nil) {
+    init(video: Video) {
         self.video = video
-        self._viewModel = StateObject(wrappedValue: viewModel ?? VideoManagementViewModel())
+        self._viewModel = StateObject(wrappedValue: VideoManagementViewModel.create())
         self._editedCaption = State(initialValue: video.caption)
         self._currentPrivacyLevel = State(initialValue: video.privacyLevel)
     }
@@ -131,5 +131,8 @@ private struct CaptionEditorView: View {
 #Preview {
     NavigationView {
         VideoManagementView(video: .mock)
+            .task {
+                // Preview setup can happen here if needed
+            }
     }
 }
-- 
2.39.5 (Apple Git-154)

