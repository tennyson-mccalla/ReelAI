From a5ed7097d7da058a0a90ba65e65ede0b3c67d08e Mon Sep 17 00:00:00 2001
From: Tennyson McCalla <tennyson.mccalla@gmail.com>
Date: Sat, 8 Feb 2025 18:22:02 -0600
Subject: [PATCH 1/3] fix: improve video playback and transitions

- Fix black screen and flickering during video transitions
- Improve player lifecycle management and cleanup
- Add proper audio session setup
- Fix video seeking timing
- Only show and load one video at a time
- Remove redundant player item creation
- Improve error handling and logging
- Fix SwiftLint issues
---
 .../ViewModels/Feed/VideoFeedViewModel.swift  | 120 ++++----
 ReelAI/Views/Feed/VideoFeedView.swift         | 260 ++++++++++++------
 ReelAI/Views/Player/VideoPlayerView.swift     | 240 ++++++----------
 3 files changed, 315 insertions(+), 305 deletions(-)

diff --git a/ReelAI/ViewModels/Feed/VideoFeedViewModel.swift b/ReelAI/ViewModels/Feed/VideoFeedViewModel.swift
index 8197b02..dfe7e17 100644
--- a/ReelAI/ViewModels/Feed/VideoFeedViewModel.swift
+++ b/ReelAI/ViewModels/Feed/VideoFeedViewModel.swift
@@ -1,11 +1,8 @@
-// Core feed management and state
-// ~100 lines
-
 import FirebaseDatabase
 import AVFoundation
 
 @MainActor
-final class VideoFeedViewModel: ObservableObject {
+class VideoFeedViewModel: NSObject, ObservableObject {
     struct FeedState {
         var isLoading = false
         var videos: [Video] = []
@@ -21,18 +18,21 @@ final class VideoFeedViewModel: ObservableObject {
     var error: String? { state.error }
     var loadingMessage: String? { state.loadingMessage }
 
-    let preloader: VideoPreloader
     private let paginator: FeedPaginator
     private let database: DatabaseReference
+    private var preloadedVideos: Set<String> = []
 
-    private var lastPlayingId: String?  // Store last playing video
+    override init() {
+        self.database = Database.database().reference()
+        self.paginator = FeedPaginator()
+        super.init()
+    }
 
     init(database: DatabaseReference = Database.database().reference(),
-         paginator: FeedPaginator = .init(),
-         preloader: VideoPreloader = .init()) {
+         paginator: FeedPaginator = .init()) {
         self.database = database
         self.paginator = paginator
-        self.preloader = preloader
+        super.init()
     }
 
     func loadVideos() {
@@ -43,24 +43,37 @@ final class VideoFeedViewModel: ObservableObject {
 
     private func loadVideosWithRetry(delay: TimeInterval = 1.0) async {
         state.isLoading = true
+        state.loadingMessage = "Loading videos..."
         print("üì° Loading videos...")
 
         do {
             print("üì° Fetching next batch...")
             let videos = try await paginator.fetchNextBatch(from: database)
             print("üì° Got \(videos.count) videos")
-            await MainActor.run {
-                // Shuffle once and store the order
-                if state.videos.isEmpty {
-                    state.videos = videos.shuffled()
-                } else {
-                    state.videos = videos
-                }
+            
+            guard !videos.isEmpty else {
+                state.error = "No videos available"
                 state.isLoading = false
                 state.loadingMessage = nil
-                print("üì° Updated state with videos")
+                return
             }
-            preloader.prefetchVideos(after: videos.first?.id)
+            
+            // Shuffle once and store the order
+            if state.videos.isEmpty {
+                state.videos = videos.shuffled()
+                // Set initial playing video
+                if currentlyPlayingId == nil {
+                    currentlyPlayingId = state.videos.first?.id
+                    print("üì± Set initial playing video: \(currentlyPlayingId ?? "none")")
+                }
+            } else {
+                state.videos = videos
+            }
+            
+            state.isLoading = false
+            state.loadingMessage = nil
+            print("üì° Updated state with videos: \(videos.count) videos available")
+            
         } catch {
             print("‚ùå Load error: \(error)")
             await handleLoadError(error, delay: delay)
@@ -69,31 +82,27 @@ final class VideoFeedViewModel: ObservableObject {
 
     private func handleLoadError(_ error: Error, delay: TimeInterval) async {
         print("‚ùå Failed to load videos: \(error.localizedDescription)")
-        await MainActor.run {
-            state.error = error.localizedDescription
-            state.isLoading = false
-            print("‚ùå Updated state with error")
-        }
-    }
-
-    func playerItem(for videoId: String) -> AVPlayerItem? {
-        preloader.playerItem(for: videoId)
+        state.error = error.localizedDescription
+        state.isLoading = false
+        print("‚ùå Updated state with error")
     }
 
-    func updateScrollDirection(from oldId: String, to newId: String) {
-        preloader.updateScrollDirection(from: oldId, to: newId)
+    func preloadVideo(_ video: Video) async {
+        guard !preloadedVideos.contains(video.id) else { return }
+        preloadedVideos.insert(video.id)
+        print("üé• Preloading video: \(video.id)")
     }
-
-    func cleanupCache(keeping currentId: String) {
-        preloader.cleanupCache(keeping: currentId)
+    
+    func cancelPreload(_ videoId: String) {
+        preloadedVideos.remove(videoId)
+        print("üé• Cancelled preload for: \(videoId)")
     }
 
     func cleanup() {
-        preloader.cleanup()
+        preloadedVideos.removeAll()
         paginator.cleanup()
     }
 
-    // Add these methods for controlled state modification
     func setLoading(_ isLoading: Bool) {
         state.isLoading = isLoading
     }
@@ -102,43 +111,26 @@ final class VideoFeedViewModel: ObservableObject {
         state.error = message
     }
 
-    func trackVideoLoadTime(videoId: String, action: String) {
-        // Implementation
-    }
-
     func reset() {
         state = FeedState()
+        preloadedVideos.removeAll()
         loadVideos()
     }
 
-    func prefetchVideos(after videoId: String?) {
-        preloader.prefetchVideos(after: videoId)
-    }
-
-    func setVideos(_ newVideos: [Video]) {
-        state.videos = newVideos
-    }
-
-    func loadNextBatch() {
-        Task {
-            await loadVideosWithRetry()
-        }
+    func handleBackground() async {
+        print("üì± App entered background")
+        // Pause current video if needed
     }
 
-    func handleBackground() {
-        if let currentId = currentlyPlayingId {
-            lastPlayingId = currentId  // Remember which video was playing
-            currentlyPlayingId = nil
-        }
+    func handleForeground() async {
+        print("üì± App entered foreground")
+        // Resume current video if needed
     }
-
-    func handleForeground() {
-        if let lastId = lastPlayingId {
-            print("üîÑ Resuming video: \(lastId)")
-            Task { @MainActor in
-                currentlyPlayingId = lastId
-                lastPlayingId = nil
-            }
-        }
+    
+    // For previews only
+    #if DEBUG
+    func setVideos(_ videos: [Video]) {
+        state.videos = videos
     }
+    #endif
 }
diff --git a/ReelAI/Views/Feed/VideoFeedView.swift b/ReelAI/Views/Feed/VideoFeedView.swift
index 7f8537b..7da094e 100644
--- a/ReelAI/Views/Feed/VideoFeedView.swift
+++ b/ReelAI/Views/Feed/VideoFeedView.swift
@@ -1,8 +1,12 @@
 import SwiftUI
+import AVKit
+import UIKit
 
+@MainActor
 struct VideoFeedView: View {
     @StateObject private var viewModel: VideoFeedViewModel
-    @State private var lastVideoId: String?
+    @State private var dragOffset: CGFloat = 0
+    @State private var isDragging: Bool = false
     @Environment(\.scenePhase) private var scenePhase
 
     init(viewModel: VideoFeedViewModel? = nil) {
@@ -10,124 +14,204 @@ struct VideoFeedView: View {
         _viewModel = StateObject(wrappedValue: vm)
     }
 
-    private func debugPrint(_ message: String) {
-        print(message)
-    }
-
     var body: some View {
-        ZStack {
-            Color.black.ignoresSafeArea()
-
-            if viewModel.isLoading && viewModel.videos.isEmpty {
-                VStack(spacing: 0) {
-                    ForEach(0..<3) { _ in
-                        ShimmerView()
-                            .frame(width: UIScreen.main.bounds.width, height: UIScreen.main.bounds.height)
-                    }
+        GeometryReader { _ in
+            ZStack {
+                Color.black.ignoresSafeArea()
+                
+                if viewModel.isLoading && viewModel.videos.isEmpty {
+                    loadingView
+                } else if !viewModel.videos.isEmpty {
+                    videoFeedContent(in: GeometryProxy())
+                } else if let error = viewModel.error {
+                    errorView(error)
                 }
-            } else {
-                SnapScrollView(currentIndex: .init(get: {
-                    viewModel.videos.firstIndex(where: { $0.id == viewModel.currentlyPlayingId }) ?? 0
-                }, set: { newIndex in
-                    Task { @MainActor in
-                        viewModel.currentlyPlayingId = viewModel.videos[newIndex].id
-                    }
-                })) {
+            }
+            .onChange(of: scenePhase) { _, newPhase in
+                Task { @MainActor in
+                    await handleScenePhaseChange(newPhase)
+                }
+            }
+            .task {
+                if viewModel.videos.isEmpty {
+                    await viewModel.loadVideos()
+                }
+            }
+            .navigationBarHidden(true)
+        }
+    }
+    
+    @ViewBuilder
+    private func videoFeedContent(in geometry: GeometryProxy) -> some View {
+        GeometryReader { _ in
+            ScrollViewReader { proxy in
+                ScrollView(.vertical, showsIndicators: false) {
                     LazyVStack(spacing: 0) {
                         ForEach(viewModel.videos) { video in
-                            VideoPlayerView(
-                                videoURL: video.videoURL,
-                                videoId: video.id,
-                                feedViewModel: viewModel
-                            )
-                            .frame(width: UIScreen.main.bounds.width, height: UIScreen.main.bounds.height)
+                            videoCell(for: video, in: geometry)
+                                .id(video.id)
                         }
                     }
-                } onSnap: { index in
-                    let video = viewModel.videos[index]
-                    viewModel.preloader.preloadNextVideo(after: video.id, videos: viewModel.videos)
+                }
+                .scrollDisabled(true)
+                .highPriorityGesture(createDragGesture(proxy: proxy))
+                .onAppear {
+                    if viewModel.currentlyPlayingId == nil {
+                        viewModel.currentlyPlayingId = viewModel.videos.first?.id
+                    }
                 }
             }
         }
-        .edgesIgnoringSafeArea(.all)
-        .onAppear {
-            viewModel.loadVideos()
+    }
+    
+    private func videoCell(for video: Video, in geometry: GeometryProxy) -> some View {
+        let isCurrentVideo = viewModel.currentlyPlayingId == video.id
+        return VideoPlayerView(
+            videoURL: video.videoURL,
+            videoId: video.id,
+            feedViewModel: viewModel,
+            isPlaying: isCurrentVideo
+        )
+        .frame(width: geometry.size.width, height: geometry.size.height)
+        .offset(y: calculateOffset(for: video, dragOffset: dragOffset, in: geometry))
+        .opacity(isCurrentVideo ? 1 : 0)
+    }
+    
+    private func createDragGesture(proxy: ScrollViewProxy) -> some Gesture {
+        DragGesture(minimumDistance: 10)
+            .onChanged { value in
+                handleDragChange(value)
+            }
+            .onEnded { value in
+                handleDragEnd(value, proxy: proxy)
+            }
+    }
+    
+    private func handleDragChange(_ value: DragGesture.Value) {
+        guard let currentIndex = viewModel.videos.firstIndex(where: { $0.id == viewModel.currentlyPlayingId }) else {
+            return
         }
-        .onDisappear {
-            viewModel.cleanup()
+        
+        isDragging = true
+        let translation = value.translation.height
+        let screenHeight = UIScreen.main.bounds.height
+        
+        // Update drag offset with resistance
+        let threshold = screenHeight * 0.3
+        if abs(translation) > threshold {
+            let excess = abs(translation) - threshold
+            let damping = 0.2
+            let dampedExcess = excess * damping
+            dragOffset = (translation < 0 ? -1 : 1) * (threshold + dampedExcess)
+        } else {
+            dragOffset = translation
         }
-        .onChange(of: scenePhase) { _, newPhase in
-            switch newPhase {
-            case .background:
-                viewModel.handleBackground()
-            case .active:
-                viewModel.handleForeground()
-            default:
-                break
+    }
+    
+    private func handleDragEnd(_ value: DragGesture.Value, proxy: ScrollViewProxy) {
+        guard let currentIndex = viewModel.videos.firstIndex(where: { $0.id == viewModel.currentlyPlayingId }) else {
+            return
+        }
+        
+        isDragging = false
+        let translation = value.translation.height
+        let progress = translation / UIScreen.main.bounds.height
+        
+        if abs(progress) >= 0.2 {
+            let nextIndex = progress > 0 ? 
+                max(0, currentIndex - 1) : 
+                min(viewModel.videos.count - 1, currentIndex + 1)
+            
+            withAnimation(.spring(response: 0.3, dampingFraction: 0.8)) {
+                dragOffset = 0
+                viewModel.currentlyPlayingId = viewModel.videos[nextIndex].id
+                proxy.scrollTo(viewModel.videos[nextIndex].id, anchor: .center)
+            }
+        } else {
+            withAnimation(.spring(response: 0.3, dampingFraction: 0.8)) {
+                dragOffset = 0
+                proxy.scrollTo(viewModel.videos[currentIndex].id, anchor: .center)
             }
         }
     }
-
+    
+    private func handleScenePhaseChange(_ newPhase: ScenePhase) async {
+        switch newPhase {
+        case .background:
+            await viewModel.handleBackground()
+        case .active:
+            await viewModel.handleForeground()
+        default:
+            break
+        }
+    }
+    
+    private func calculateOffset(for video: Video, dragOffset: CGFloat, in geometry: GeometryProxy) -> CGFloat {
+        guard let currentIndex = viewModel.videos.firstIndex(where: { $0.id == viewModel.currentlyPlayingId }),
+              let videoIndex = viewModel.videos.firstIndex(where: { $0.id == video.id }) else {
+            return 0
+        }
+        
+        let screenHeight = geometry.size.height
+        let indexDiff = CGFloat(videoIndex - currentIndex)
+        let baseOffset = indexDiff * screenHeight
+        return baseOffset + dragOffset
+    }
+    
+    @ViewBuilder
+    private var loadingView: some View {
+        VStack(spacing: 16) {
+            ProgressView()
+                .progressViewStyle(CircularProgressViewStyle(tint: .white))
+                .scaleEffect(1.5)
+            Text("Loading videos...")
+                .foregroundColor(.white)
+        }
+    }
+    
     @ViewBuilder
     private func errorView(_ error: String) -> some View {
-        VStack {
+        VStack(spacing: 16) {
             Text(error)
                 .foregroundColor(.white)
-                .padding()
-                .background(Color.black.opacity(0.7))
-                .cornerRadius(10)
-
             Button("Retry") {
-                viewModel.reset()
+                Task {
+                    await viewModel.loadVideos()
+                }
             }
             .foregroundColor(.white)
             .padding()
+            .background(Color.gray.opacity(0.3))
+            .cornerRadius(8)
         }
     }
 }
 
 // MARK: - Previews
-#Preview("Default") {
-    VideoFeedView()
-}
-
-#Preview("Loading") {
-    VideoFeedView(viewModel: {
-        let vm = VideoFeedViewModel()
-        vm.setLoading(true)
-        return vm
-    }())
+#if DEBUG
+struct VideoFeedView_Previews: PreviewProvider {
+    static var previews: some View {
+        VideoFeedView()
+    }
 }
 
-#Preview("Error") {
-    VideoFeedView(viewModel: {
-        let vm = VideoFeedViewModel()
-        vm.setError("Network connection unavailable")
-        return vm
-    }())
+struct VideoFeedViewLoading_Previews: PreviewProvider {
+    static var previews: some View {
+        VideoFeedView(viewModel: {
+            let vm = VideoFeedViewModel()
+            vm.setLoading(true)
+            return vm
+        }())
+    }
 }
 
-// MARK: - Preview Helpers
-#if DEBUG
-extension VideoFeedViewModel {
-    static var mock: VideoFeedViewModel {
-        let model = VideoFeedViewModel()
-        if let url = URL(string: "https://example.com/1.mp4"),
-           let thumbUrl = URL(string: "https://example.com/1.jpg") {
-            model.setVideos([
-                Video(
-                    id: "1",
-                    userId: "user1",
-                    videoURL: url,
-                    thumbnailURL: thumbUrl,
-                    createdAt: Date(),
-                    caption: "Test video",
-                    likes: 0,
-                    comments: 0
-                )
-            ])
-        }
-        return model
+struct VideoFeedViewError_Previews: PreviewProvider {
+    static var previews: some View {
+        VideoFeedView(viewModel: {
+            let vm = VideoFeedViewModel()
+            vm.setError("Network connection unavailable")
+            return vm
+        }())
     }
 }
 #endif
diff --git a/ReelAI/Views/Player/VideoPlayerView.swift b/ReelAI/Views/Player/VideoPlayerView.swift
index bc61b8c..b6ab11c 100644
--- a/ReelAI/Views/Player/VideoPlayerView.swift
+++ b/ReelAI/Views/Player/VideoPlayerView.swift
@@ -1,182 +1,116 @@
-// Main container view with core player setup
-// ~100 lines
-
 import SwiftUI
 import AVKit
 
 struct VideoPlayerView: View {
     let videoURL: URL
     let videoId: String
-    @ObservedObject var feedViewModel: VideoFeedViewModel
-    @StateObject private var playerViewModel: PlayerViewModel
+    let feedViewModel: VideoFeedViewModel
+    let isPlaying: Bool
+    
+    @State private var player: AVPlayer?
+    @State private var isLoaded = false
     @State private var playerState = PlayerState()
-    let onLoadingStateChanged: (Bool) -> Void
-
-    // Add this to get window scene safe area
-    @Environment(\.safeAreaInsets) private var safeAreaInsets
-
-    // Standard tab bar height
-    private let tabBarHeight: CGFloat = 49
-
-    init(videoURL: URL,
-         videoId: String,
-         feedViewModel: VideoFeedViewModel,
-         onLoadingStateChanged: @escaping (Bool) -> Void = { _ in }) {
-        self.videoURL = videoURL
-        self.videoId = videoId
-        self.feedViewModel = feedViewModel
-        self.onLoadingStateChanged = onLoadingStateChanged
-        _playerViewModel = StateObject(wrappedValue: PlayerViewModel())
-    }
-
+    @State private var observation: NSKeyValueObservation?
+    
     var body: some View {
-        GeometryReader { geometry in
+        GeometryReader { _ in
             ZStack {
-                if let error = playerState.error {
-                    PlayerOverlay.ErrorView(
-                        error: error,
-                        onRetry: { Task { await loadVideo(from: videoURL) }}
-                    )
+                if let player = player, isLoaded {
+                    VideoPlayer(player: player)
+                        .edgesIgnoringSafeArea(.all)
+                        .disabled(true)
                 } else {
-                    CustomVideoPlayer(player: playerViewModel.player) {
-                        playerState.isPlaying.toggle()
-                        if playerState.isPlaying {
-                            playerViewModel.player?.play()
-                        } else {
-                            playerViewModel.player?.pause()
-                        }
-                    }
-                    .ignoresSafeArea(.all)
-                    .frame(width: geometry.size.width, height: geometry.size.height)
-                    .onChange(of: feedViewModel.currentlyPlayingId) { _, newValue in
-                        if newValue != videoId {
-                            playerViewModel.player?.pause()
-                            playerViewModel.cleanup()
-                        } else {
-                            if playerViewModel.player == nil {
-                                Task {
-                                    await loadVideo(from: videoURL)
-                                }
-                            } else {
-                                playerViewModel.player?.play()
-                            }
-                        }
-                    }
-
-                    PlayerControls(
-                        state: $playerState,
-                        player: playerViewModel.player
-                    )
-                    .padding(.bottom, 0)
-
-                    ProgressBar(progress: playerViewModel.progress)
-                        .frame(height: 2)
-                        .frame(maxHeight: .infinity, alignment: .bottom)
-                        .padding(.bottom, geometry.safeAreaInsets.bottom + tabBarHeight + 95)
+                    Color.black
+                }
+                
+                // Loading indicator
+                if !isLoaded {
+                    ProgressView()
+                        .progressViewStyle(CircularProgressViewStyle(tint: .white))
+                        .scaleEffect(1.5)
                 }
             }
-            .onChange(of: geometry.frame(in: .global).minY) { _, newY in
-                let threshold = UIScreen.main.bounds.height * 0.5
-                let isFullyVisible = abs(newY) < threshold
-                if isFullyVisible && feedViewModel.currentlyPlayingId != videoId {
-                    Task { @MainActor in
-                        feedViewModel.currentlyPlayingId = videoId
-                    }
+            .onAppear {
+                print("üé• VideoPlayerView appeared for \(videoId)")
+                if player == nil {
+                    setupPlayer()
                 }
             }
-        }
-        .ignoresSafeArea(.all)
-        .background(Color.black)
-        .onAppear {
-            Task {
-                await loadVideo(from: videoURL)
+            .onDisappear {
+                print("üé• VideoPlayerView disappeared for \(videoId)")
+                cleanupPlayer()
             }
-        }
-        .onChange(of: playerViewModel.player?.status) { _, status in
-            if status == .readyToPlay {
-                onLoadingStateChanged(false)
+            .onChange(of: isPlaying) { _, playing in
+                handlePlaybackChange(playing)
             }
         }
-        .onDisappear {
-            playerViewModel.cleanup()
-        }
-        .frame(maxWidth: .infinity, maxHeight: .infinity)
-        .contentShape(Rectangle())  // Make entire area tappable
-        .gesture(
-            DragGesture(minimumDistance: 20)
-                .onChanged { _ in
-                    // Optionally pause video during drag
-                }
-                .onEnded { _ in
-                    // Handle drag completion if needed
-                }
-        )
+        .edgesIgnoringSafeArea(.all)
+        .background(Color.black)
     }
-
-    private func loadVideo(from url: URL) async {
-        onLoadingStateChanged(true)
-
-        if tryLoadPrefetchedItem() {
+    
+    private func handlePlaybackChange(_ playing: Bool) {
+        guard let player = player, isLoaded else {
+            print("üé• Player not ready for playback change on \(videoId)")
             return
         }
-
-        await loadFromCacheOrNetwork(url: url)
-    }
-
-    private func tryLoadPrefetchedItem() -> Bool {
-        if let prefetchedItem = feedViewModel.playerItem(for: videoId) {
-            print("üéØ Using prefetched video: \(videoId)")
-            prefetchedItem.preferredForwardBufferDuration = 10
-            prefetchedItem.automaticallyPreservesTimeOffsetFromLive = false
-            playerViewModel.loadVideo(playerItem: prefetchedItem)
-            playerViewModel.configurePlayback(shouldLoop: true)
-            onLoadingStateChanged(false)
-            return true
+        
+        if playing {
+            print("üé• Starting playback for \(videoId)")
+            player.seek(to: .zero)
+            player.play()
+            playerState.isPlaying = true
+        } else {
+            print("üé• Pausing playback for \(videoId)")
+            player.pause()
+            playerState.isPlaying = false
         }
-        return false
     }
-
-    private func loadFromCacheOrNetwork(url: URL) async {
-        do {
-            let cachedURL = try await VideoCacheManager.shared.cacheVideo(
-                from: url,
-                withIdentifier: url.lastPathComponent
-            )
-            let asset = AVURLAsset(url: cachedURL)
-            let playerItem = AVPlayerItem(asset: asset)
-            playerItem.preferredForwardBufferDuration = 10
-            playerItem.automaticallyPreservesTimeOffsetFromLive = false
-            playerViewModel.loadVideo(playerItem: playerItem)
-            playerViewModel.configurePlayback(shouldLoop: true)
-
-            // Load duration after playback starts
-            if #available(iOS 16.0, *) {
-                Task {
-                    let duration = try await asset.load(.duration)
-                    print("üìè Loading video duration: \(duration.seconds) seconds")
+    
+    private func setupPlayer() {
+        print("üé• Setting up player for \(videoId)")
+        
+        // Create player and item
+        let player = AVPlayer(url: videoURL)
+        player.automaticallyWaitsToMinimizeStalling = false
+        
+        // Store the player first
+        self.player = player
+        
+        // Add observer for loading status
+        observation = player.currentItem?.observe(\.status) { item, _ in
+            Task { @MainActor in
+                switch item.status {
+                case .readyToPlay:
+                    print("üé• Player ready for \(videoId)")
+                    isLoaded = true
+                    if isPlaying {
+                        player.play()
+                        playerState.isPlaying = true
+                    }
+                case .failed:
+                    print("‚ùå Player failed for \(videoId): \(String(describing: item.error))")
+                default:
+                    break
                 }
             }
-        } catch {
-            print("‚ùå Video load error: \(error.localizedDescription)")
-            playerState.error = error
-            onLoadingStateChanged(false)
         }
-    }
-}
-
-// Add this extension to get safe area insets
-private extension EnvironmentValues {
-    var safeAreaInsets: EdgeInsets {
-        guard let windowScene = UIApplication.shared.connectedScenes.first as? UIWindowScene,
-              let window = windowScene.windows.first else {
-            return .init()
+        
+        // Enable audio session
+        do {
+            try AVAudioSession.sharedInstance().setCategory(.playback, mode: .default)
+            try AVAudioSession.sharedInstance().setActive(true)
+        } catch {
+            print("‚ùå Failed to set audio session: \(error)")
         }
-        return window.safeAreaInsets.insets
     }
-}
-
-private extension UIEdgeInsets {
-    var insets: EdgeInsets {
-        EdgeInsets(top: top, leading: left, bottom: bottom, trailing: right)
+    
+    private func cleanupPlayer() {
+        print("üé• Cleaning up player for \(videoId)")
+        player?.pause()
+        observation?.invalidate()
+        observation = nil
+        player = nil
+        isLoaded = false
+        playerState.isPlaying = false
     }
 }
-- 
2.39.5 (Apple Git-154)

